<!doctype html><html class=no-js lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><title>剖析 HTTPS 的设计思路 - 小牛写字的地方</title><script>(function(a,b){a[b]=a[b].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="剖析 HTTPS 的设计思路"><meta property="og:description" content="HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer ，安全的超文本传输协议），是以安全为目标的HTTP通道。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。这个系统的最初研发由 Netscape 进行。
如今，HTTPS 已经渐渐成为主流，很多大型网站都已经全站 HTTPS 化。那么有了 HTTP 后为什么还需要有 HTTPS 呢？——为了解决 HTTP 的不足。
HTTP 的不足之处
 通信内容使用明文——内容可能被窃听 不验证通信方的身份——可能遭遇伪装 无法验证报文的完整性——报文有可能已遭篡改  现在来看看一般的明文通信都存在什么问题。
使用明文传输内容存在的问题 在理想的信息流动情况下，信息能够安全达到目的地且未受到任何攻击。
我们平时生活中所说的“攻击”，更多地有”主动“的意义。但是这里的攻击，囊括了主动和被动两层意义。根据 ITU-T 的 X.800 推荐标准（OSI 安全框架），攻击分为以下几类：
 被动攻击  窃听：一个非授权方介入系统的攻击，获取了传输的信息，破坏保密性。 流量攻击：监听流量来判断通信的性质。   主动攻击  伪装/冒充：个实体假装成另外一个实体。 伪造/篡改：将伪造的客体插入系统中，破坏真实性。 重放：获取有效数据段以重播的方式获取对方信任。 DoS / DDoS：导致合法用户不能够访问正常网络服务的行为都算是拒绝服务攻击。    一般的明文网络访问，无法防止上面所述的攻击方式。通过应用密码学的知识，一般可以阻止上面多数的攻击。（但是密码学对流量攻击、重放和 (D)DoS 还做不了太多。防止重放攻击还需要在更高的应用层做一些处理。）
下面，我们用密码学来解决它可以解决的风险：
 窃听风险：黑客可以获知通信内容。 —— 保证数据的隐私性 篡改风险：黑客可以修改通信内容。 —— 保证数据的完整性 冒充风险：黑客可以冒充他人身份参与通信。 —— 保证身份正确。  解决窃听风险：加密 1、对称加密 。有流式、分组两种，加密和解密都是使用的同一个密钥。 例如：DES、AES 等"><meta property="og:type" content="article"><meta property="og:url" content="http://xuxinhang.github.io/posts/%E5%89%96%E6%9E%90-https-%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-01-11T23:13:38+00:00"><meta property="article:modified_time" content="2019-01-11T23:13:38+00:00"><meta itemprop=name content="剖析 HTTPS 的设计思路"><meta itemprop=description content="HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer ，安全的超文本传输协议），是以安全为目标的HTTP通道。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。这个系统的最初研发由 Netscape 进行。
如今，HTTPS 已经渐渐成为主流，很多大型网站都已经全站 HTTPS 化。那么有了 HTTP 后为什么还需要有 HTTPS 呢？——为了解决 HTTP 的不足。
HTTP 的不足之处
 通信内容使用明文——内容可能被窃听 不验证通信方的身份——可能遭遇伪装 无法验证报文的完整性——报文有可能已遭篡改  现在来看看一般的明文通信都存在什么问题。
使用明文传输内容存在的问题 在理想的信息流动情况下，信息能够安全达到目的地且未受到任何攻击。
我们平时生活中所说的“攻击”，更多地有”主动“的意义。但是这里的攻击，囊括了主动和被动两层意义。根据 ITU-T 的 X.800 推荐标准（OSI 安全框架），攻击分为以下几类：
 被动攻击  窃听：一个非授权方介入系统的攻击，获取了传输的信息，破坏保密性。 流量攻击：监听流量来判断通信的性质。   主动攻击  伪装/冒充：个实体假装成另外一个实体。 伪造/篡改：将伪造的客体插入系统中，破坏真实性。 重放：获取有效数据段以重播的方式获取对方信任。 DoS / DDoS：导致合法用户不能够访问正常网络服务的行为都算是拒绝服务攻击。    一般的明文网络访问，无法防止上面所述的攻击方式。通过应用密码学的知识，一般可以阻止上面多数的攻击。（但是密码学对流量攻击、重放和 (D)DoS 还做不了太多。防止重放攻击还需要在更高的应用层做一些处理。）
下面，我们用密码学来解决它可以解决的风险：
 窃听风险：黑客可以获知通信内容。 —— 保证数据的隐私性 篡改风险：黑客可以修改通信内容。 —— 保证数据的完整性 冒充风险：黑客可以冒充他人身份参与通信。 —— 保证身份正确。  解决窃听风险：加密 1、对称加密 。有流式、分组两种，加密和解密都是使用的同一个密钥。 例如：DES、AES 等"><meta itemprop=datePublished content="2019-01-11T23:13:38+00:00"><meta itemprop=dateModified content="2019-01-11T23:13:38+00:00"><meta itemprop=wordCount content="420"><meta itemprop=keywords content="HTTPS,密码学,"><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=dns-prefetch href=//fonts.googleapis.com><link rel=dns-prefetch href=//fonts.gstatic.com><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/custom.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title=小牛写字的地方 rel=home><div class="logo__item logo__text"><div class=logo__title>小牛写字的地方</div><div class=logo__tagline>专属小牛的写字工作区</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>首页</span></a></li><li class=menu__item><a class=menu__link href=/posts/><span class=menu__text>文章</span></a></li><li class=menu__item><a class=menu__link href=/about/><span class=menu__text>关于我</span></a></li><li class=menu__item><a class=menu__link href=https://github.com/xuxinhang><span class=menu__text>GitHub</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>剖析 HTTPS 的设计思路</h1><div class="post__meta meta"><div class="meta__item-author meta__item"><svg class="meta__icon icon icon-author" width="16" height="16" viewBox="0 0 12 16"><path d="M6 1c2.2.0 3.5 2 3.5 4.5C9.5 7 8.9 8.2 8 9c2.9.8 4 2.5 4 5v1H0v-1c0-2.5 1.1-4.2 4-5-.9-.8-1.5-2-1.5-3.5C2.5 3 3.8 1 6 1z"/></svg><span class=meta__text>小牛</span></div><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2019-01-11T23:13:38Z>2019-01-11</time></div></div></header><div class="post__toc toc"><div class=toc__title>Page content</div><div class=toc__menu><nav id=TableOfContents><ul><li><a href=#使用明文传输内容存在的问题>使用明文传输内容存在的问题</a></li><li><a href=#解决窃听风险加密>解决窃听风险：加密</a></li><li><a href=#如何防止中间人认证>如何防止中间人：认证</a><ul><li></li></ul></li><li><a href=#https-具体是怎么做的>HTTPS 具体是怎么做的</a><ul><li><a href=#x509-证书的信任链>X.509 证书的信任链</a></li></ul></li><li><a href=#结语>结语</a></li></ul></nav></div></div><div class="content post__content clearfix"><p>HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer ，安全的超文本传输协议），是以安全为目标的HTTP通道。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。这个系统的最初研发由 Netscape 进行。</p><p>如今，HTTPS 已经渐渐成为主流，很多大型网站都已经全站 HTTPS 化。那么有了 HTTP 后为什么还需要有 HTTPS 呢？——为了解决 HTTP 的不足。</p><p><strong>HTTP 的不足之处</strong></p><ul><li>通信内容使用明文——内容可能被窃听</li><li>不验证通信方的身份——可能遭遇伪装</li><li>无法验证报文的完整性——报文有可能已遭篡改</li></ul><p>现在来看看一般的明文通信都存在什么问题。</p><h2 id=使用明文传输内容存在的问题>使用明文传输内容存在的问题</h2><p>在理想的信息流动情况下，信息能够安全达到目的地且未受到任何攻击。</p><p>我们平时生活中所说的“攻击”，更多地有”主动“的意义。但是这里的攻击，囊括了主动和被动两层意义。根据 ITU-T 的 X.800 推荐标准（OSI 安全框架），攻击分为以下几类：</p><ul><li><strong>被动攻击</strong><ul><li><strong>窃听</strong>：一个非授权方介入系统的攻击，获取了传输的信息，破坏保密性。</li><li><strong>流量攻击</strong>：监听流量来判断通信的性质。</li></ul></li><li><strong>主动攻击</strong><ul><li><strong>伪装/冒充</strong>：个实体假装成另外一个实体。</li><li><strong>伪造/篡改</strong>：将伪造的客体插入系统中，破坏真实性。</li><li><strong>重放</strong>：获取有效数据段以重播的方式获取对方信任。</li><li>DoS / DDoS：导致合法用户不能够访问正常网络服务的行为都算是拒绝服务攻击。</li></ul></li></ul><p>一般的明文网络访问，无法防止上面所述的攻击方式。通过应用密码学的知识，一般可以阻止上面多数的攻击。（但是密码学对流量攻击、重放和 (D)DoS 还做不了太多。防止重放攻击还需要在更高的应用层做一些处理。）</p><p>下面，我们用密码学来解决它可以解决的风险：</p><ol><li><strong>窃听</strong>风险：黑客可以获知通信内容。 —— 保证数据的隐私性</li><li><strong>篡改</strong>风险：黑客可以修改通信内容。 —— 保证数据的完整性</li><li><strong>冒充</strong>风险：黑客可以冒充他人身份参与通信。 —— 保证身份正确。</li></ol><h2 id=解决窃听风险加密>解决窃听风险：加密</h2><p>1、对称加密 。有流式、分组两种，加密和解密都是使用的同一个密钥。 例如：DES、AES 等</p><p>2、非对称加密 。加密使用的密钥和解密使用的密钥是不相同的，分别称为：公钥、私钥，公钥和算法都是公开的，私钥是保密的。非对称加密算法性能低，但是安全性超强，由于其加密特性，非对称加密算法能加密的数据长度也是有限的。 例如：RSA、DSA。</p><p>非对称加密是最安全的。但是在频繁大量的网络数据传输过程中，非对称加密算法的性能限制会成为整个系统的瓶颈。如果需要长时间且频繁地传输信息，全程使用非对称加密是万万不可以的。</p><pre><code class=language-sequence data-lang=sequence>Client-&gt;Server:  I want to talk with you.
Server-&gt;Client:  It's my public key.
Client-&gt;Server:  Message encoded by public key.
Note: The hacker knows nothing.
Note: Server knows this messgae.
</code></pre><p>只要算法和密钥选择得当，使用对称加密算法可以得到同样安全的加密效果。但是使用对称加密密钥也有它自己的问题：通信双方如何商定出密钥。通信双方共享同一个对称密钥，如果双方已经知道这一密钥，之后的信息使用这一密钥进行加密完全没有问题。 但是，不同的客户端、服务器数量庞大，所以双方都需要维护大量的密钥，维护成本很高，密钥极易泄露。因此，对称密钥必须动态生成。但问题就在于，密钥如何安全的分享出去。密钥钥如果泄漏，加密就失去了意义。</p><p>我们可以将对称加密和非对称加密联合起来来解决这个问题。</p><p>对于没有见过面的双方，第一次请求通信的时候，S 先发出自己的公钥，C 记下 S 的公钥。之后 S 和 C 协商得出一个对称密钥。因为是通信非对称加密后的，监听者仅凭他们之间的通信内容是难以破译出它们协商出的对称密钥的。之后，S、C 使用对称密钥进行正式的通信，监听者不知道他们的密钥，所以也无法破译他们之间的通信内容。</p><p>看起来很完美。</p><h2 id=如何防止中间人认证>如何防止中间人：认证</h2><p>考虑下面的情况：中间人代理了 S、C 之间的所有流量。</p><pre><code class=language-sequence data-lang=sequence>
C -&gt; H: 请求公钥
H -&gt; S: 请求公钥
S -&gt; H: 返回真实公钥
Note: 伪造密钥对
H -&gt; C: 返回伪造的公钥
Note: 用伪造公钥加密明文
C -&gt; H: 密文
Note: 解密得到明文
Note: 用真实公钥加密明文
H -&gt; S: 密文
Note: 用私钥解密得明文
Note: 无感知
Note: 无感知
</code></pre><p>中间人通过伪造公钥私钥对，伪装成 S，同时 C、S 双方对此毫无感知。其实即使不伪造密钥对，只要中间人监听到了公钥，就足以把 S 发给 C 的消息给解密出来。这里的问题是：如何确认 ”S“ 是真实的而不是中间人 ”H“，如何保证公钥的准确 。</p><p>为了保证公钥的真实性，引入了认证这一手段。</p><h4 id=数字签名>数字签名</h4><p>数字签名基于公钥私钥体制，将一段文本通过哈希（hash）和私钥加密处理后生成数字签名。接收者用发送者的公共密钥对签名解密，并将之与收到的信息“指纹”进行比较，以确定其真实性。只要签名者的私钥不被泄漏，数字签名就是可信的。</p><pre><code>+---------------------+
| A digital signature |            +---------+              +--------+
|(not to be confused  |----Hash---&gt;| 消息摘要 |---私钥加密---&gt;| 数字签名 |
|with a digital       |            +---------+              +--------+
+---------------------+
</code></pre><h4 id=数字证书>数字证书</h4><p>数字证书，是由一个官方的证书颁发机构（CA）签发的一组数据。这种证书很难伪造，用于使用者的身份证明。</p><p>数字证书包含以下内容：</p><ul><li>对象名称（人、服务器、组织、公司等）</li><li><strong>对象的公开密钥</strong></li><li>其它扩展信息</li><li>= = = = = = = = = = = = = = = = = = = = =</li><li><strong>附上证书颁发机构的数字签名</strong></li></ul><p>使用证书，正常的通信流程是这样子的：</p><ol><li><p>S 会把自己的数字证书下发给 C</p></li><li><p>C 通过证书中“证书颁发机构的数字签名”来验证证书的来源和完整性。</p><p>具体做法是使用 CA 的公钥解密并对比。</p></li><li><p>一旦证书被认证通过，C 就从证书中取出 “对象的公开密钥”，之后就用这个公钥来加密数据。</p></li></ol><p>CA 的私钥仅它自己知道，因此黑客无法伪造 CA 的签名，也不能得到合法的证书。只要证书认证通过，它的公钥就是可信的。</p><p>到这里，这整个过程才算是无懈可击的。</p><h2 id=https-具体是怎么做的>HTTPS 具体是怎么做的</h2><p>HTTPS 的通信过程和上面描述的基本一致。</p><pre><code>-&gt; 客户端向服务端发送请求
-&gt; 服务端返回数字证书
-&gt; 客户端用自己的CA[主流的CA机构证书一般都内置在各个主流浏览器中]公钥去解密证书,如果证书有问题会提示风险
-&gt; 如果证书没问题客户端会生成一个对称加密的随机秘钥然后再和刚刚解密的服务器端的公钥对数据进行加密,然后发送给服务器端
-&gt; 服务器端收到以后会用自己的私钥对客户端发来的对称秘钥进行解密
-&gt; 之后双方就拿着这个对称加密秘钥来进行正常的通信`
</code></pre><p><img src=1683d4a61df00d44.png alt=img></p><p>整个过程中，HTTPS 证书使用的是 X.509 证书标准。</p><p>X.509 是密码学里公钥证书的格式标准。 X.509 证书己应用在包括TLS/SSL 在内的众多网络协议里。</p><p>X.509 是由国际电信联盟（ITU-T）制定的数字证书标准。为了提供公用网络用户目录信息服务， ITU 于 1988 年制定了 X.500 系列标准。其中 X.500 和 X.509 是安全认证系统的核心， X.500 定义了一种区别命名规则，以命名树来确保用户名称的唯一性； X.509 则为 X.500 用户名称提供了通信实体鉴别机制，并规定了实体鉴别过程中广泛适用的证书语法和数据接口， X.509 称之为证书。</p><p>HTTPS协议使用的是 SSL 证书，它<strong>遵从</strong>了 X.509 标准。</p><ul><li>证书格式版本号</li><li>证书序列号</li><li>过期时间</li><li>证书办法机构</li><li>证书使用的签名算法</li><li>过期时间</li><li>对象名称（人、服务器、组织、公司等）</li><li><strong>对象的公开密钥</strong></li><li>其它扩展信息</li><li>= = = = = = = = = = = = = = = = = = = = =</li><li><strong>附上证书颁发机构的数字签名</strong></li></ul><p>在浏览器中，查看证书内容非常容易。</p><p><img src=1683d4ddfb84b2a4.jpg alt></p><p><img src=1683d4e633a40e37.jpg alt></p><h3 id=x509-证书的信任链>X.509 证书的信任链</h3><p>到现在，还有一个问题没有被解决。使用证书认证的前提是 C 知道 S 的公钥，可是S 的公钥不能在不安全的网络中直接发送给 C。</p><p>此时就引入了<strong>证书颁发机构</strong>（Certificate Authority，简称CA），世界上CA数量并不多。C 预先拥有所有受信任CA的证书。如果 S 想要一个证书，它先向 CA 申请，CA 使用它自己的私钥对 S 的证书进行签名。接下来，C 和 S 要相互通信的时候，S 将它的证书发给 C。 C 拥有所有 CA 的可信公钥，所以 C 可以验证证书的真实性。</p><p>如此一来，C 信任 CA，CA信任 S 使得 C 信任 S，信任链（Chain Of Trust）就是这样形成的。</p><p>事实上，客户端 C 内置的是 CA的根证书(Root Certificate)，HTTPS协议中服务器会发送证书链（Certificate Chain）给客户端。</p><p>如上图，“Wikipedia”的证书的证书链如下。这里，C 一定是信任 根证书 Root CA 的，于是 C 最终信任 &ldquo;Wikimedia Foundation, Inc&rdquo; 。这里有一个细节，根证书是由根证书自己来签名和颁发的。</p><table><thead><tr><th>证书</th><th>证书颁发者</th></tr></thead><tbody><tr><td>GlobalSign Root CA（根证书）</td><td>GlobalSign Root CA（自签名）</td></tr><tr><td>GlobalSign Organization Validation CA - SHA256 - G2</td><td>GlobalSign Root CA</td></tr><tr><td>&ldquo;Wikimedia Foundation, Inc.&rdquo;</td><td>GlobalSign Organization Validation CA</td></tr></tbody></table><p>最终，C 只要内置世界上仅有的几个根证书就可以自行校验所有的 HTTPS 证书了。S 的证书必须经过某一个 CA 的签名。但是现在的操作系统和浏览器也允许用户自行添加自己的根证书。例如 <code>12306.cn</code> 曾经要求用户自行下载安装指定的根证书。</p><p>从下图可以看到，根证书 “GlobalSign Root CA” 早已经内置到系统内部了。</p><p><img src=1683d4f084d0aceb.jpg alt></p><h2 id=结语>结语</h2><p>使用密码学理论，客户端和服务器之间实现了信息的保密传输。密码学中对称加密、非对称加密和哈希函数在整个通信建立的过程中都发挥了作用，并且都缺一不可。密码学的理论知识已经成为安全通信的理论基础。</p><p>现在 HTTPS 已经被广泛运用到各大网站中，它已经成为我们日常中用到的技术，而我们对此并没有太大的感知。密码学提供了很多已经被我们视为理所当然的工具，我们使用的大多数安全通信工具都仰仗于它。</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/https/ rel=tag>HTTPS</a></li><li class=tags__item><a class="tags__link btn" href=/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/ rel=tag>密码学</a></li></ul></div></footer></article></main><div class="authorbox clearfix"><figure class=authorbox__avatar><img alt="小牛 avatar" src=/img/avatar.png class=avatar height=90 width=90></figure><div class=authorbox__header><span class=authorbox__name>About 小牛</span></div><div class=authorbox__description>就只是一只小牛而已</div></div><nav class="pager flex"><div class="pager__item pager__item--prev"><a class=pager__link href=/posts/pro-git-tips/ rel=prev><span class=pager__subtitle>«&#8201;Previous</span><p class=pager__title>Pro Git Tips</p></a></div><div class="pager__item pager__item--next"><a class=pager__link href=/posts/%E4%BD%BF%E7%94%A8heroku%E6%88%96openshift%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%85%8D%E8%B4%B9%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91v2ray%E6%9C%8D%E5%8A%A1/ rel=next><span class=pager__subtitle>Next&#8201;»</span><p class=pager__title>使用 Heroku 或 OpenShift 搭建自己的免费科学上网 V2Ray 服务</p></a></div></nav></div><aside class="sidebar sidebar--left"><div class="widget-search widget"><form class=widget-search__form role=search method=get action=https://google.com/search><label><input class=widget-search__field type=search placeholder=SEARCH… name=q aria-label=SEARCH…></label>
<input class=widget-search__submit type=submit value=Search>
<input type=hidden name=sitesearch value=http://xuxinhang.github.io/></form></div><div class="widget-recent widget"><h4 class=widget__title>Recent Posts</h4><div class=widget__content><ul class=widget__list><li class=widget__item><a class=widget__link href=/posts/%E4%BD%BF%E7%94%A8tex%E7%9B%92%E5%AD%90%E7%9A%84%E4%B8%A4%E4%B8%AA%E4%BE%8B%E5%AD%90/>使用 TeX 盒子的两个例子</a></li><li class=widget__item><a class=widget__link href=/posts/%E6%9D%82%E8%B0%88%E6%80%8E%E6%A0%B7%E6%95%B4%E7%90%86%E5%90%84%E5%BC%8F%E5%90%84%E6%A0%B7%E7%9A%84%E4%B8%AA%E4%BA%BA%E6%96%87%E4%BB%B6/>杂谈：怎样整理各式各样的个人文件？</a></li><li class=widget__item><a class=widget__link href=/posts/%E6%80%8E%E6%A0%B7%E8%88%92%E9%80%82%E5%9C%B0%E4%BD%BF%E7%94%A8vim%E7%A0%81%E5%AD%97%E5%86%99%E6%96%87%E7%AB%A0/>怎样舒适地使用 Vim 码字写文章</a></li><li class=widget__item><a class=widget__link href=/posts/latex%E5%85%A5%E9%97%A8%E5%B0%8F%E8%AE%B0vim+vimtex+latex%E5%88%9D%E4%BD%93%E9%AA%8C/>LaTeX 入门小记：Vim + Vimtex + LaTeX 初体验</a></li><li class=widget__item><a class=widget__link href=/posts/%E7%94%A8%E7%BA%AFcss%E5%AE%9E%E7%8E%B0%E9%95%82%E7%A9%BA%E6%95%88%E6%9E%9C/>用纯 CSS 实现镂空效果</a></li><li class=widget__item><a class=widget__link href=/posts/%E4%BD%BF%E7%94%A8heroku%E6%88%96openshift%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%85%8D%E8%B4%B9%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91v2ray%E6%9C%8D%E5%8A%A1/>使用 Heroku 或 OpenShift 搭建自己的免费科学上网 V2Ray 服务</a></li><li class=widget__item><a class=widget__link href=/posts/%E5%89%96%E6%9E%90-https-%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/>剖析 HTTPS 的设计思路</a></li><li class=widget__item><a class=widget__link href=/posts/pro-git-tips/>Pro Git Tips</a></li><li class=widget__item><a class=widget__link href=/posts/%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%99%BB%E5%BD%95%E6%8E%A7%E5%88%B6%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%9E%8B/>管理系统的登录控制？手写一个发布订阅模型！</a></li><li class=widget__item><a class=widget__link href=/posts/%E5%85%B3%E4%BA%8Epromise%E7%9A%84%E5%87%A0%E4%B8%AAtips/>关于Promise的几个Tips</a></li></ul></div></div><div class="widget-categories widget"><h4 class=widget__title>Categories</h4><div class=widget__content><ul class=widget__list><li class=widget__item><a class=widget__link href=/categories/latex/>LaTeX</a></li></ul></div></div><div class="widget-taglist widget"><h4 class=widget__title>Tags</h4><div class=widget__content><a class="widget-taglist__link widget__link btn" href=/tags/blend-mode/ title="blend mode">blend mode</a>
<a class="widget-taglist__link widget__link btn" href=/tags/context/ title=Context>Context</a>
<a class="widget-taglist__link widget__link btn" href=/tags/css/ title=CSS>CSS</a>
<a class="widget-taglist__link widget__link btn" href=/tags/flex/ title=Flex>Flex</a>
<a class="widget-taglist__link widget__link btn" href=/tags/git/ title=Git>Git</a>
<a class="widget-taglist__link widget__link btn" href=/tags/https/ title=HTTPS>HTTPS</a>
<a class="widget-taglist__link widget__link btn" href=/tags/javascript/ title=Javascript>Javascript</a>
<a class="widget-taglist__link widget__link btn" href=/tags/latex/ title=LaTeX>LaTeX</a>
<a class="widget-taglist__link widget__link btn" href=/tags/mask/ title=mask>mask</a>
<a class="widget-taglist__link widget__link btn" href=/tags/promise/ title=Promise>Promise</a>
<a class="widget-taglist__link widget__link btn" href=/tags/react/ title=React>React</a>
<a class="widget-taglist__link widget__link btn" href=/tags/ssh/ title=SSH>SSH</a>
<a class="widget-taglist__link widget__link btn" href=/tags/v2ray/ title=V2Ray>V2Ray</a>
<a class="widget-taglist__link widget__link btn" href=/tags/vim/ title=Vim>Vim</a>
<a class="widget-taglist__link widget__link btn" href=/tags/webpack/ title=Webpack>Webpack</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/ title=发布订阅>发布订阅</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/ title=密码学>密码学</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/ title=开发工具>开发工具</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F/ title=混合模式>混合模式</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/ title=科学上网>科学上网</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/ title=设计模式>设计模式</a>
<a class="widget-taglist__link widget__link btn" href=/tags/%E9%95%82%E7%A9%BA/ title=镂空>镂空</a></div></div></aside></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2021 xuxinhang.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script><script src=/js/custom.js></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML" async></script></body></html>