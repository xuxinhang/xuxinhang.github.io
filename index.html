<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>小牛写代码的地方</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="小牛写代码的地方">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="小牛写代码的地方">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Cattle">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="小牛写代码的地方" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">小牛写代码的地方</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Code is Poetry</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/13/hello-world/" class="article-date">
  <time class="dt-published" datetime="2021-03-13T14:08:05.500Z" itemprop="datePublished">2021-03-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/13/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/13/hello-world/" data-id="ckm7t0sow000bgkug3yd2ck3s" data-title="Hello World" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-杂谈：怎样整理各式各样的个人文件？" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/02/24/%E6%9D%82%E8%B0%88%EF%BC%9A%E6%80%8E%E6%A0%B7%E6%95%B4%E7%90%86%E5%90%84%E5%BC%8F%E5%90%84%E6%A0%B7%E7%9A%84%E4%B8%AA%E4%BA%BA%E6%96%87%E4%BB%B6%EF%BC%9F/" class="article-date">
  <time class="dt-published" datetime="2021-02-24T15:11:38.000Z" itemprop="datePublished">2021-02-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/02/24/%E6%9D%82%E8%B0%88%EF%BC%9A%E6%80%8E%E6%A0%B7%E6%95%B4%E7%90%86%E5%90%84%E5%BC%8F%E5%90%84%E6%A0%B7%E7%9A%84%E4%B8%AA%E4%BA%BA%E6%96%87%E4%BB%B6%EF%BC%9F/">杂谈：怎样整理各式各样的个人文件？</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>第一级子目录按使用情况分类，将待做的和已完成的区分开来（Inbox + Archive）</p>
<pre>
|--Prepare 筹备文件（Inbox文件夹）  
|--Archive 存档文件（子目录按照性质划分）  
|--Dropbox 正在用的文件（同步到网盘）
</pre>

<ul>
<li>Inbox 与 Dropbox 合并也可</li>
<li>存档文件子目录按性质分类，工作区子目录可以不分子目录</li>
<li>若存在二级子目录,二级子目录按照性质划分   <pre>
  ├─Archive（存档）  
  ├─Catalog（笔记）  
  ├─Culture（文化）  
  ├─Gallery（图库）  
  ├─Project（项目）
  </pre>
  OR  <pre>
  |--Dropbox  
  | My Works (下级运用COTA法分类)  
  | My Lifes
  </pre></li>
</ul>
<ul>
<li>  程序文件与数据文件分开</li>
<li>  <strong>按目的而不是按文件格式</strong>（把有关的文件存放在一起，而不去管他们的格式）</li>
<li>  <strong>只保存对自己有用的文件，不用的马上删除</strong></li>
</ul>
<h1 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h1><p><strong>涉及隐私的文件一定要引入加密</strong></p>
<p>哪些文件需要同步？(1)即时更新的文件，  (2) 应用使用的数据库文件， (3) 分享协作的文件。</p>
<h1 id="Inbox"><a href="#Inbox" class="headerlink" title="Inbox"></a>Inbox</h1><p>InBox 目录，存放不能及时整理归档，或者暂时不知如何分类的临时文件</p>
<ul>
<li>及时归档：InBox → 归档</li>
<li>时间变动是在命名文件上实现的</li>
<li>按照工作项目扁平地放置，不作按类型的分类</li>
</ul>
<h1 id="归档"><a href="#归档" class="headerlink" title="归档"></a>归档</h1><ul>
<li>不超过三层</li>
<li>MECE 分析法（Mutually Exclusive Collectively Exhaustive）</li>
<li>存档文件子目录按性质分类</li>
</ul>
<h1 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h1><blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/52037758">资料存档方法 - Elishebhajiang的文章 - 知乎</a> </p>
</blockquote>
<h3 id="备份方案根据数据重要度进行区分"><a href="#备份方案根据数据重要度进行区分" class="headerlink" title="备份方案根据数据重要度进行区分"></a>备份方案根据数据重要度进行区分</h3><ul>
<li>  <strong>重要 独有</strong>：个人照片、文章及素材、笔记及日记、财务报表……这类属于个人的核心资料，是必须确保万无一失的。</li>
<li>  <strong>不重要 独有</strong>：一些稀奇古怪不知是否重要的个人资料</li>
<li>  <strong>重要 非独有</strong>：主要是工作文档，比如工作中和同事协同创作的文章、代码等等。你有一份，同事也有一份。这类资料，虽然丢失后花费一定代价可以找回，但也应做好同步备份。</li>
<li>  <strong>不重要 非独有</strong>：可有可无的资料，丢失也能重新找回。</li>
<li>  <strong>重要数据至少存三分</strong>，工作集，备份，备份的备份</li>
</ul>
<h3 id="要做到"><a href="#要做到" class="headerlink" title="要做到"></a>要做到</h3><ul>
<li>定期转存，不管放什么介质里，都需要定期检查、修复</li>
<li>尽量地理上多地冗余</li>
<li>不相干文件不要打包在一起</li>
<li>使用好一点的介质</li>
<li>格式转存，减小体积  </li>
</ul>
<h1 id="我自己目前的一些做法"><a href="#我自己目前的一些做法" class="headerlink" title="我自己目前的一些做法"></a>我自己目前的一些做法</h1><ol>
<li>要留着的照片要定期备份，拍的没用的照片定期整理删掉</li>
<li>自己生产的文档，作业资料什么的，有用的放云盘</li>
<li>其它杂乱的长期来看没用的文档，留在临时文件夹并定期清理</li>
<li>电子书什么有收藏价值的文档</li>
<li>代码统一放 GitHub，可以创建仓库，也可以使用Gist</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/02/24/%E6%9D%82%E8%B0%88%EF%BC%9A%E6%80%8E%E6%A0%B7%E6%95%B4%E7%90%86%E5%90%84%E5%BC%8F%E5%90%84%E6%A0%B7%E7%9A%84%E4%B8%AA%E4%BA%BA%E6%96%87%E4%BB%B6%EF%BC%9F/" data-id="ckm7t0sp7000ogkug7zn0302w" data-title="杂谈：怎样整理各式各样的个人文件？" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-怎样舒适地使用Vim码字写文章" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/06/28/%E6%80%8E%E6%A0%B7%E8%88%92%E9%80%82%E5%9C%B0%E4%BD%BF%E7%94%A8Vim%E7%A0%81%E5%AD%97%E5%86%99%E6%96%87%E7%AB%A0/" class="article-date">
  <time class="dt-published" datetime="2020-06-28T11:39:00.000Z" itemprop="datePublished">2020-06-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LaTeX/">LaTeX</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/06/28/%E6%80%8E%E6%A0%B7%E8%88%92%E9%80%82%E5%9C%B0%E4%BD%BF%E7%94%A8Vim%E7%A0%81%E5%AD%97%E5%86%99%E6%96%87%E7%AB%A0/">怎样舒适地使用 Vim 码字写文章</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在 Vim 中使用 LaTeX 或者 Markdown 码字总会感到两种痛苦：一是开启自动折行后一个自然段的东西显示为好几行，可敲 <code>j</code>  <code>k</code> 会让光标直接跳到下一个自然段；二是写码汉字的时候输入法总是要不停地切换——插入模式下写文章要用中文输入法码字，回到普通模式还得切换回英文敲命令。</p>
<blockquote>
<p>提出这个问题是因为这段时间一直在使用 LaTeX 写中文文章，以上两个问题相当影响效率。我想很多人也遇到了这个问题，所以在这里分享一下解决方案。<br>另外，上一篇文章写到了怎样使用 Vim 愉快地写 LaTeX，这一篇也算是对前面文章的补充。<br>当然，你也可以把这里的方法应用到任何需要使用 Vim 写大量中文的地方。</p>
</blockquote>
<p>毗邻：LaTeX 入门小记：Vim + Vimtex + LaTeX 初体验​zhuanlan.zhihu.com<img src="/v2-0c924e835b6c9ccc4888771e4c41a38f_180x120.jpg" alt="图标"></p>
<p>所以，是时候解决这两个问题了！</p>
<h2 id="一-修改-j-k-的上下移动光标的行为"><a href="#一-修改-j-k-的上下移动光标的行为" class="headerlink" title="(一) 修改 j  k 的上下移动光标的行为"></a>(一) 修改 <code>j</code>  <code>k</code> 的上下移动光标的行为</h2><p>Vim 以换行标记为一行的结束。在 Vim 中，可以开启对长行自动回绕，也就是当一行过长超过显示区域的时候自动回绕，绕出来的行称为虚拟行。在写文章的时候，你经常会输入好多这样的长行，也许你更喜欢称之为“自然段”，但 Vim 认为是这是一行。</p>
<p>Vim 默认是开启自动回绕的。你如果关闭了也可以使用 <code>:set wrap</code> 来开启，也可写在 <code>.vimrc</code> 里。 Vim 默认使用 <code>gk</code> 与 <code>gj</code> 来在虛拟行间上下移动光标，使用 <code>k</code> 与 <code>j</code> 在行间移动光标。</p>
<p>考虑到经常需要在虚拟行间移动光标，而且按 <code>gk</code>与<code>gj</code>并不方便，所以不妨把这两组按键的功能交换一下：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">noremap</span>  <span class="symbol">&lt;buffer&gt;</span>  <span class="keyword">j</span> gj</span><br><span class="line"><span class="keyword">noremap</span>  <span class="symbol">&lt;buffer&gt;</span>  <span class="keyword">k</span> gk</span><br><span class="line"><span class="keyword">noremap</span>  <span class="symbol">&lt;buffer&gt;</span> gj <span class="keyword">j</span>  </span><br><span class="line"><span class="keyword">noremap</span>  <span class="symbol">&lt;buffer&gt;</span> gk <span class="keyword">k</span>  </span><br><span class="line"><span class="keyword">set</span>  wrap  </span><br></pre></td></tr></table></figure>
<p>这里 <code>noremap</code> 定义了一个不进行重映射的键映射。 如果使用 <code>map</code> 这样的命令，第三行的 <code>gj-&gt;j</code> 就会应用到第一行的 <code>j-&gt;gj</code> 上，导致 <code>j-&gt;gj-&gt;j</code>，还是没用。<code>&lt;buffer&gt;</code> 表示此键映射只应用到缓冲区内，毕竟这个功能只在你写文章的时候才需要。</p>
<p>你也可以依葫芦画瓢修改方向键 <code>&lt;Up&gt;&lt;Down&gt;</code> 的键映射。</p>
<blockquote>
<p>想要了解键映射的更多技术细节可以看 <code>:help usr_40</code>。</p>
</blockquote>
<p>下面把这段 Vim 脚本放到哪里呢？我推荐使用 Vim 的文件类型插件特性。例如对 tex 文件创建文件插件，就在 <code>~/.vim/ftplugin</code> 或 <code>~/vimfiles/ftplugin</code> 中创建文件 <code>tex.vim</code> ，然后把上面的键映射写在里面。下次再打开 tex 文件就可以体验到独特的 <code>j</code>  <code>k</code> 了。</p>
<p>你也可以把你自己的其它针对 tex 文件的配置脚本写到里面。</p>
<blockquote>
<p>关于文件类型插件的技术细节参见 <code>:help filetype-plugin</code>。</p>
</blockquote>
<h2 id="二-借助-vim-xkbswitch-插件实现不同模式间输入法的自动切换"><a href="#二-借助-vim-xkbswitch-插件实现不同模式间输入法的自动切换" class="headerlink" title="(二) 借助 vim-xkbswitch 插件实现不同模式间输入法的自动切换"></a>(二) 借助 vim-xkbswitch 插件实现不同模式间输入法的自动切换</h2><p>vim-xkbswitch 配合额外的动态链接库实现了在不同模式间切换时记录与恢复键盘布局的功能。 这样，就可以在我们切回插入模式时自动回到中文输入法了。这是 vim-xkbswitch 的文档：<a target="_blank" rel="noopener" href="https://github.com/lyokha/vim-xkbswitch">lyokha/vim-xkbswitch</a></p>
<p>首先把 vim-xkbswitch 本身安装好：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&quot; 此处以 vim-plug 为例，你可以使用其它的插件管理器</span></span><br><span class="line">Plug <span class="string">&#x27;lyokha/vim-xkbswitch&#x27;</span>  </span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:XkbSwitchEnabled</span> =  <span class="number">1</span>  <span class="comment">&quot;不要忘记这一行</span></span><br></pre></td></tr></table></figure>
<p>不要忘记配置 <code>g:XkbSwitchEnabled</code> 的值。vim-xkbswitch还有更多高级的配置，可以了解一下。</p>
<p>然后，安装配套的动态库。你可以在 vim-xkbswitch 文档的 About 章节下找到不同平台下的动态链接库及安装指引。动态链接库应该位于变量 g:XkbSwitchLib 指定的位置处，你可以自行指定也可以直接使用默认值，使用下面的命令查看它的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:echo g:XkbSwitchLib</span><br></pre></td></tr></table></figure>
<p>重启 Vim 之后就应该可以使用了。</p>
<p><strong>针对 Windows 用户最后要特别强调一点。</strong> 切换到英文的时候是要切换到<strong>英文布局</strong>而不是中文输入法的英文模式。请大家多调整调整试试。大概就是下面这个样子。Windows 10 用户可能需要手动添加英文布局，可以使用 Alt+Shift 切换。</p>
<p><img src="/2020/06/28/%E6%80%8E%E6%A0%B7%E8%88%92%E9%80%82%E5%9C%B0%E4%BD%BF%E7%94%A8Vim%E7%A0%81%E5%AD%97%E5%86%99%E6%96%87%E7%AB%A0/v2-c1a9af5e5206ffbb931fa6f3f8ce5ba3_b.png"></p>
<hr>
<p>这就是这两个问题的解决方案。最后祝各位使用 Vim 码字愉快！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/06/28/%E6%80%8E%E6%A0%B7%E8%88%92%E9%80%82%E5%9C%B0%E4%BD%BF%E7%94%A8Vim%E7%A0%81%E5%AD%97%E5%86%99%E6%96%87%E7%AB%A0/" data-id="ckm7t0sp3000jgkug9l5hhimg" data-title="怎样舒适地使用 Vim 码字写文章" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LaTeX/" rel="tag">LaTeX</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vim/" rel="tag">Vim</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-LaTeX入门小记：Vim+Vimtex+LaTeX初体验" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/11/25/LaTeX%E5%85%A5%E9%97%A8%E5%B0%8F%E8%AE%B0%EF%BC%9AVim+Vimtex+LaTeX%E5%88%9D%E4%BD%93%E9%AA%8C/" class="article-date">
  <time class="dt-published" datetime="2019-11-25T11:15:00.000Z" itemprop="datePublished">2019-11-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LaTeX/">LaTeX</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/11/25/LaTeX%E5%85%A5%E9%97%A8%E5%B0%8F%E8%AE%B0%EF%BC%9AVim+Vimtex+LaTeX%E5%88%9D%E4%BD%93%E9%AA%8C/">LaTeX 入门小记：Vim + Vimtex + LaTeX 初体验</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>前几天写作业的时候突发奇想，想用传说中的LaTeX写一份作业交上去，正好前几天也被迷一样的Word搞得苦不堪言。</p>
<p>之前收藏过一篇来自外国小哥的文章<br> <a target="_blank" rel="noopener" href="https://castel.dev/post/lecture-notes-1/">How I’m able to take notes in mathematics lectures using LaTeX and Vim​</a></p>
<p>知乎上也有相关的中文介绍<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/61036165">机器之心：世界上最好的编辑器Vim：1700多页数学笔记是如何实时完成的</a></p>
<p>就以这篇文章为起点，我在一台Windows电脑上开始了 Vim + LaTeX 的踩坑旅程……</p>
<h2 id="安装LaTeX环境"><a href="#安装LaTeX环境" class="headerlink" title="安装LaTeX环境"></a>安装LaTeX环境</h2><p><strong>不要再用CTeX套装了。</strong> CTeX 套装是一个LaTeX发行版，里面包含了包括CTeX宏包在内的一套适合中文排版的工具集。它本质上是MiKTex的修改版，但已经很久没有更新过，里面的工具已经过于陈旧。CTeX 宏包是集成了中文支持、字体、版式为一体的一组宏包和文档类的合集。CTeX宏包已经发布到了Tex Live与MiKTeX两大发行版的仓库里，所以不使用CTeX套装也可以享受CTeX宏包带来的便利。这里就请大家直接用MiKTeX或者TeX Live吧！</p>
<p>我用的MiKTeX，整个安装过程还是很顺畅的。安装完后有一个“MiKTeX Console”，它是MiKTeX的控制台，可以手动安装升级宏包、修改镜像地址什么的。安装向导里有个选项，大意是遇到缺失的包该怎样处理，默认就好。</p>
<blockquote>
<p>题外话：我当时安装MiKTeX的时候它没有把自己的路径加到PATH里</p>
</blockquote>
<p><img src="/2019/11/25/LaTeX%E5%85%A5%E9%97%A8%E5%B0%8F%E8%AE%B0%EF%BC%9AVim+Vimtex+LaTeX%E5%88%9D%E4%BD%93%E9%AA%8C/v2-0ec0595f725cfb2ec8b58ad28f2e84b1_b.png"><br><img src="/2019/11/25/LaTeX%E5%85%A5%E9%97%A8%E5%B0%8F%E8%AE%B0%EF%BC%9AVim+Vimtex+LaTeX%E5%88%9D%E4%BD%93%E9%AA%8C/v2-d844eb849f295d87d5cea16f05970993_b.png"></p>
<p>TeX Live 也有类似的 Console。里面“选项”下可以改镜像地址，改成一个中国境内的地址后下载速度就不错了。不过我个人更偏好 MiKTex 一些。</p>
<p><img src="/2019/11/25/LaTeX%E5%85%A5%E9%97%A8%E5%B0%8F%E8%AE%B0%EF%BC%9AVim+Vimtex+LaTeX%E5%88%9D%E4%BD%93%E9%AA%8C/v2-bec3cf587887872af73a396311379b10_b.png"></p>
<h2 id="安装配置Vim与Vimtex"><a href="#安装配置Vim与Vimtex" class="headerlink" title="安装配置Vim与Vimtex"></a>安装配置Vim与Vimtex</h2><p>Vim官网上有gVim可供下载，当然没有谁会用它提供的那个所谓GUI的…</p>
<blockquote>
<p>安装时记得勾选 “Install for command line”</p>
</blockquote>
<p><img src="/2019/11/25/LaTeX%E5%85%A5%E9%97%A8%E5%B0%8F%E8%AE%B0%EF%BC%9AVim+Vimtex+LaTeX%E5%88%9D%E4%BD%93%E9%AA%8C/v2-f5d4fe37982e77420c4bcbb883914a6a_b.png"></p>
<p>然后开始学习使用Vim，这里不包教，也不包会…</p>
<p>之后安装 Vimtex，如果你初次用 Vim，还得安装个 vim-plug 这样的插件管理器，不麻烦。</p>
<p><code>~/.vimrc</code> 里也得加入相关的配置</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&quot;....</span></span><br><span class="line">Plug <span class="string">&#x27;lervag/vimtex&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:tex_flavor</span>=<span class="string">&#x27;latex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; 阅读器相关的配置 包含正反向查找功能 仅供参考</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:vimtex_view_general_viewer</span> = <span class="string">&#x27;SumatraPDF&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:vimtex_view_general_options_latexmk</span> = <span class="string">&#x27;-reuse-instance&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:vimtex_view_general_options</span></span><br><span class="line">\ = <span class="string">&#x27;-reuse-instance -forward-search @tex @line @pdf&#x27;</span></span><br><span class="line">\ . <span class="string">&#x27; -inverse-search &quot;&#x27;</span> . exepath(<span class="variable">v:progpath</span>)</span><br><span class="line">\ . <span class="string">&#x27; --servername &#x27;</span> . <span class="variable">v:servername</span></span><br><span class="line">\ . <span class="string">&#x27; --remote-send \&quot;^&lt;C-\^&gt;^&lt;C-n^&gt;&#x27;</span></span><br><span class="line">\ . <span class="string">&#x27;:execute &#x27;</span><span class="string">&#x27;drop &#x27;</span><span class="string">&#x27; . fnameescape(&#x27;</span><span class="string">&#x27;\%f&#x27;</span><span class="string">&#x27;)^&lt;CR^&gt;&#x27;</span></span><br><span class="line">\ . <span class="string">&#x27;:\%l^&lt;CR^&gt;:normal\! zzzv^&lt;CR^&gt;&#x27;</span></span><br><span class="line">\ . <span class="string">&#x27;:call remote_foreground(&#x27;</span><span class="string">&#x27;&#x27;</span>.<span class="variable">v:servername</span>.<span class="string">&#x27;&#x27;</span><span class="string">&#x27;)^&lt;CR^&gt;^&lt;CR^&gt;\&quot;&quot;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> conceallevel=<span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:tex_conceal</span>=<span class="string">&#x27;abdmg&#x27;</span></span><br><span class="line"><span class="comment">&quot;...</span></span><br></pre></td></tr></table></figure>
<p>我的配置是相当简单的，基本和原文保持一致，但有两个不一样的地方：</p>
<ul>
<li>  我没有关闭<code>vimtex_quickfix_mode</code>。“quickfix mode”是指当编译完成之后，会弹出一个split，告诉你哪里有warning啊，哪里有error啊。如果不是过于追求速度，看看warning并把它们全都消灭掉也不错……</li>
<li>  我使用了 SumatraPDF 作为PDF阅读器，而非Zathura。（因为Windows上没有Zathura）当然你也可以使用其它的PDF阅读器，比如说使用Zathura就写 <code>let g:vimtex_view_method=&#39;zathura&#39;</code></li>
<li>  <code>:help g:vimtex_view_method</code>里针对不同的阅读器也有不同的推荐配置。如果使用其它的阅读器，那么具体配置内容请看帮助文档。</li>
<li><em>其中包含正向查找和反向查找的相关配置。</em> 正向查找是指可以让阅读器中的文档定位至源码中光标对应的位置，反向查找指在源码中定位到阅读器文档中某一点处对应的位置。帮助文档提供的阅读器的推荐配置中包含了正反向查找的相关内容。</li>
</ul>
<h2 id="安装PDF阅读器"><a href="#安装PDF阅读器" class="headerlink" title="安装PDF阅读器"></a>安装PDF阅读器</h2><p>我使用的是SumatraPDF，在Vimtex中相关配置就在上面了。<code>:h vimtex-options</code> 里推荐了不少PDF阅读器并提供了推荐配置。你也可以使用自己喜欢的，但还是建议使用 Vimtex 推荐的PDF阅读器，毕竟一些实用功能还是需要阅读器的配合。</p>
<blockquote>
<p>Windows用户要记得把路径加到PATH里啊</p>
</blockquote>
<h2 id="开始写LaTeX文档"><a href="#开始写LaTeX文档" class="headerlink" title="开始写LaTeX文档"></a>开始写LaTeX文档</h2><p>从零开始学习LaTeX可以看《<a target="_blank" rel="noopener" href="http://tug.ctan.org/info/lshort/english/lshort.pdf">The Not So ShortIntroduction to LATEX2</a>》，CTeX小组和社区还翻译了中文版《<a target="_blank" rel="noopener" href="http://mirrors.ctan.org/info/lshort/chinese/lshort-zh-cn.pdf">一份不太简短的LATEX2介绍</a>》。CTAN官方访问困难也可访问<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/20490473">中国境内的CTAN镜像站</a>。另外下面这些个也不错：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://liam.page/2014/09/08/latex-introduction/">一份其实很短的 LaTeX 入门文档</a></li>
<li><a target="_blank" rel="noopener" href="https://www.kancloud.cn/thinkphp/latex/41802">一份其实很短的 LaTeX 入门文档 · 看云</a></li>
</ul>
<h3 id="关于中文-CTeX"><a href="#关于中文-CTeX" class="headerlink" title="关于中文/CTeX"></a>关于中文/CTeX</h3><p>这里推荐使用 CTeX 宏包。如果以UTF-8保存，<code>[UTF8]</code>是一定要加的。</p>
<figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>[UTF8]&#123;ctexart&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line">你好，world!</span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure>
<h3 id="关于数学公式"><a href="#关于数学公式" class="headerlink" title="关于数学公式"></a>关于数学公式</h3><p>数学公式的规则是有那么一点复杂，还好这里有个在线LaTeX公式编辑器可供学习研究。我常用它来看一些不常用的数学记号怎么写（我怎么能记得住所有的数学记号啊）。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://www.codecogs.com/latex/eqneditor.php">http://www.codecogs.com/latex/eqneditor.php</a></p>
</blockquote>
<h3 id="关于使用-Vimtex"><a href="#关于使用-Vimtex" class="headerlink" title="关于使用 Vimtex"></a>关于使用 Vimtex</h3><p>Vimtex提供了一些默认的 key mappings，可以在 <code>:h vimtex-usage</code> 里看到。摘几个我觉得好使的列在下面吧。（比如 vimtex-toc-open可以调出一个大纲列表，方便在不同的section/subsection之间跳转，delim-close可以直接关闭当前的环境/命令，等等。）</p>
<blockquote>
<p>⚠️ Vimtex 使用了 filetype 特性，所以相关的命令与缩进规则与只在 <code>*.tex</code> 文件中有效</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">---------------------------------------------------------------------~</span><br><span class="line">  LHS              RHS                                          MODE~</span><br><span class="line"> ---------------------------------------------------------------------~</span><br><span class="line">  &lt;localleader&gt;li  |&lt;plug&gt;(vimtex-info)|                           &#96;n&#96;</span><br><span class="line">  &lt;localleader&gt;lt  |&lt;plug&gt;(vimtex-toc-open)|                       &#96;n&#96;</span><br><span class="line">  &lt;localleader&gt;lT  |&lt;plug&gt;(vimtex-toc-toggle)|                     &#96;n&#96;</span><br><span class="line">  &lt;localleader&gt;lv  |&lt;plug&gt;(vimtex-view)|                           &#96;n&#96;</span><br><span class="line">  &lt;localleader&gt;ll  |&lt;plug&gt;(vimtex-compile)|                        &#96;n&#96;</span><br><span class="line">  &lt;localleader&gt;lo  |&lt;plug&gt;(vimtex-compile-output)|                 &#96;n&#96;</span><br><span class="line">  &lt;localleader&gt;lg  |&lt;plug&gt;(vimtex-status)|                         &#96;n&#96;</span><br><span class="line">  &lt;localleader&gt;lG  |&lt;plug&gt;(vimtex-status-all)|                     &#96;n&#96;</span><br><span class="line">  &lt;localleader&gt;lc  |&lt;plug&gt;(vimtex-clean)|                          &#96;n&#96;</span><br><span class="line">  &lt;localleader&gt;lC  |&lt;plug&gt;(vimtex-clean-full)|                     &#96;n&#96;</span><br><span class="line">  dse              |&lt;plug&gt;(vimtex-env-delete)|                     &#96;n&#96;</span><br><span class="line">  dsc              |&lt;plug&gt;(vimtex-cmd-delete)|                     &#96;n&#96;</span><br><span class="line">  cse              |&lt;plug&gt;(vimtex-env-change)|                     &#96;n&#96;</span><br><span class="line">  csc              |&lt;plug&gt;(vimtex-cmd-change)|                     &#96;n&#96;</span><br><span class="line">  &lt;F7&gt;             |&lt;plug&gt;(vimtex-cmd-create)|                     &#96;nxi&#96;</span><br><span class="line">  ]]               |&lt;plug&gt;(vimtex-delim-close)|                    &#96;i&#96;</span><br><span class="line"> ---------------------------------------------------------------------~ </span><br></pre></td></tr></table></figure>
<blockquote>
<p>科普专区： <code>&lt;localleader&gt;</code>是一个特殊的字符，区分出插件自定义的mappings 默认是一个反斜杠，也可以使用<code>let maplocalleader</code>配置自己的<code>&lt;localleader&gt;</code>字符。 比如，执行 vimtex-compile 在Normal模式下敲<code>\ll</code>就可以了</p>
</blockquote>
<h2 id="第一次编译"><a href="#第一次编译" class="headerlink" title="第一次编译"></a>第一次编译</h2><p>好了，你现在有了一份LaTeX源码，现在可以在Normal模式下敲<code>\ll</code>启动编译了。之后，Vimtex会调用 Latexmk 来调度不同的程序完成一次完整编译过程。（一般为了生成正确的交叉引用等，需要对源文件进行多次编译。）</p>
<p>这里 MiKTeX 会提醒你：“还没有安装Latexmk呢，需要安装吗？” 这里狠狠地点击“Install”就完事了。如果使用的是Windows，Latexmk还会提醒你还没有安装Perl解释器。啥都别说了，乖乖去 perl.org下载安装Perl，然后再启动编译一遍吧……</p>
<p><img src="/2019/11/25/LaTeX%E5%85%A5%E9%97%A8%E5%B0%8F%E8%AE%B0%EF%BC%9AVim+Vimtex+LaTeX%E5%88%9D%E4%BD%93%E9%AA%8C/v2-20eaf223a59c4c5d8e2895f3042c78b2_b.png"></p>
<p>然后继续。这时MiKTeX会提示你这个包要不要装，那个包要不要装，咱当然是一路“Install”。如果你的代码没问题的话，稍等片刻 Vimtex 就会启动 SumatraPDF展示你第一篇 LaTeX 文档的模样了。如果不幸出了一些错误，Vimtex也会告诉你第几行出现了什么问题（即上面提到的“quickfix”功能）。</p>
<p>还有更方便的功能：</p>
<ul>
<li>  每当保存文件的时候，Vimtex（其实是Latexmk）就会自动编译新的文档，SumatraPDF也会自动更新为最新的编译输出。</li>
</ul>
<p>配置了正反向查找后：</p>
<ul>
<li>  在 SumatraPDF 里双击可以让 Vim 跳转到对应的 LaTeX 代码。</li>
<li>执行<code>\lv</code>来让SumatraPDF打开编译出的文档，并跳转到光标当前所在源码处的对应位置。</li>
</ul>
<p>最后的效果就像这样——一个很简单的例子<br><img src="/2019/11/25/LaTeX%E5%85%A5%E9%97%A8%E5%B0%8F%E8%AE%B0%EF%BC%9AVim+Vimtex+LaTeX%E5%88%9D%E4%BD%93%E9%AA%8C/v2-31f3a11c06c35b30014b16d5bfbf4a60_b.png"></p>
<hr>
<p>接下来你可以换一个好用又好看的终端。我选择的是 ConEmu+PowerShell，搭配双显示器效果更佳~</p>
<p><img src="/2019/11/25/LaTeX%E5%85%A5%E9%97%A8%E5%B0%8F%E8%AE%B0%EF%BC%9AVim+Vimtex+LaTeX%E5%88%9D%E4%BD%93%E9%AA%8C/v2-cf14b93eab0497b429330df4ef5241d1_b.png"></p>
<h2 id="题外话：几个我用到的宏包"><a href="#题外话：几个我用到的宏包" class="headerlink" title="题外话：几个我用到的宏包"></a>题外话：几个我用到的宏包</h2><p>（我这次用到的宏包估计大部分情况下也会用到吧）</p>
<figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>&#123;graphicx&#125; <span class="comment">% 插图片</span></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;amsmath&#125;  <span class="comment">% 数学公式拓展</span></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;float&#125;    <span class="comment">% 浮动体控制</span></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;listings&#125; <span class="comment">% 插入代码，不过据说 minted 的效果更好一些</span></span><br></pre></td></tr></table></figure>
 <!--
<u>**其它参考**</u>
[使用 Latexmk 编译 tex 文件](https://macplay.github.io/posts/shi-yong-latexmk-bian-yi-tex-wen-jian/)
-->


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/11/25/LaTeX%E5%85%A5%E9%97%A8%E5%B0%8F%E8%AE%B0%EF%BC%9AVim+Vimtex+LaTeX%E5%88%9D%E4%BD%93%E9%AA%8C/" data-id="ckm7t0soh0002gkug3gxfg0gb" data-title="LaTeX 入门小记：Vim + Vimtex + LaTeX 初体验" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LaTeX/" rel="tag">LaTeX</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vim/" rel="tag">Vim</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-用纯CSS实现镂空效果" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/02/22/%E7%94%A8%E7%BA%AFCSS%E5%AE%9E%E7%8E%B0%E9%95%82%E7%A9%BA%E6%95%88%E6%9E%9C/" class="article-date">
  <time class="dt-published" datetime="2019-02-22T15:20:51.000Z" itemprop="datePublished">2019-02-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/02/22/%E7%94%A8%E7%BA%AFCSS%E5%AE%9E%E7%8E%B0%E9%95%82%E7%A9%BA%E6%95%88%E6%9E%9C/">用纯 CSS 实现镂空效果</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>UPDATE 2/26</p>
<p>现在为示例 CodePen 添加了厂商前缀，并在正文中添加了兼容性提示。感谢评论区的各位。</p>
</blockquote>
<p>近来研究了一下镂空效果。</p>
<!--`https://github.githubassets.com/pinned-octocat.svg`-->

<h1 id="background-clip-text"><a href="#background-clip-text" class="headerlink" title="background-clip: text"></a><code>background-clip: text</code></h1><p>背景被裁剪为文字的前景色。第一次是在 CSS-Tricks 看到的这个用法: 在 CSS-Tricks 网站上，这个玩意用得到处都是。</p>
<p>这样，做简单的图片背景镂空效果便不再困难了。关键代码只有几行。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&quot;/path/to/your/image&quot;</span>);</span><br><span class="line">  -webkit-<span class="attribute">background-clip</span>: text;  <span class="comment">/* Chrome 用户注意加 -webkit 前缀 */</span></span><br><span class="line">  <span class="attribute">background-clip</span>: text;</span><br><span class="line">  <span class="attribute">color</span>: transparent;             <span class="comment">/* 文字设为透明 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就这几行，视觉上会就会有大变化。<a target="_blank" rel="noopener" href="https://codepen.io/xuxinhang/pen/ZwdxgW">前后对比</a>：</p>
<p><img src="/2019/02/22/%E7%94%A8%E7%BA%AFCSS%E5%AE%9E%E7%8E%B0%E9%95%82%E7%A9%BA%E6%95%88%E6%9E%9C/16915c2a03989856.png"></p>
<blockquote>
<p>另外，<a target="_blank" rel="noopener" href="https://codepen.io/xuxinhang/pen/wNGwYo">这里</a>有个比上面更实用的 Demo</p>
</blockquote>
<blockquote>
<p><strong>兼容性提示</strong></p>
<p>除了 Firefox 和 Edge ，其它浏览器需要配合厂商前缀：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-webkit-<span class="attribute">background-clip</span>: text;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>background-clip</code> 既然是“background”家族的，那它天生和图片、渐变打的交道多。不过，我们做镂空总不会都是图片、渐变这种吧。如果我们想做视频、文字，甚至更复杂的 DOM 元素的镂空效果呢？</p>
<h1 id="单刀直入：-CSS-mask-属性"><a href="#单刀直入：-CSS-mask-属性" class="headerlink" title="单刀直入： CSS mask 属性"></a>单刀直入： CSS <code>mask</code> 属性</h1><p>这应该是最直接能想到的方法了。毕竟名字里就带个“mask”，谁能忽略呢？</p>
<p>CSS <code>mask-*</code> 系列属性是在 CSS Masking Module Level 1 中定义的。这个规范也定义了为很多人熟知的 <code>clip</code> 和 <code>clip-path</code> 属性，换句话说，这个CSS 模块包括遮罩和剪裁两部分。</p>
<h2 id="第一个例子"><a href="#第一个例子" class="headerlink" title="第一个例子"></a>第一个例子</h2><p>虽然是一个新的属性，但设置 mask 属性并不难。下面就是我们的第一个例子。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;masked&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.masked</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(red, orange, yellow, lightgreen, blue, purple, red);</span><br><span class="line">  -webkit-<span class="attribute">mask</span>: <span class="built_in">url</span>(<span class="string">&quot;https://github.githubassets.com/pinned-octocat.svg&quot;</span>);</span><br><span class="line">  <span class="attribute">mask</span>: <span class="built_in">url</span>(<span class="string">&quot;https://github.githubassets.com/pinned-octocat.svg&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是下面的效果啦。</p>
<p><img src="/2019/02/22/%E7%94%A8%E7%BA%AFCSS%E5%AE%9E%E7%8E%B0%E9%95%82%E7%A9%BA%E6%95%88%E6%9E%9C/16915c7824565c9e.png"></p>
<p>上面的用法还是很简单的，我们指定了一个 <code>mask</code> 参数，它的值是一张<s>从GitHub盗的</s>SVG图片。于是多彩的渐变就被<s>裁剪</s>遮罩成了那只著名的猫。</p>
<blockquote>
<p> <strong>兼容性提示</strong></p>
<p>目前 Mask Module 还处于 Candidate Recommendation 状态，不少浏览器现在需要厂商前缀。Chrome 用户和 Edge 用户请加上 <code>-webkit</code> 前缀，如 <code>-webkit-mask: ... ;</code>。Firefox 可直接使用。</p>
<p><a target="_blank" rel="noopener" href="https://caniuse.com/#search=mask">从Can I Use 可以知道</a>，加上 <code>-webkit</code>，支持 Mask 的浏览器还是不少的。</p>
<p>为了方便阅读，<em>下面的代码 <strong>均未</strong> 使用前缀</em>。</p>
</blockquote>
<h2 id="mask-大家族"><a href="#mask-大家族" class="headerlink" title="mask-* 大家族"></a>mask-* 大家族</h2><p><code>mask</code>属性实际上是诸多<code>mask-*</code>的缩写:</p>
<pre><code>mask-image
mask-repeat
mask-position
mask-clip
mask-origin
mask-size
-
mask-type
mask-composite
mask-mode
</code></pre>
<p>有没有 <code>background-*</code> 的即视感？没错，里面的不少属性都是和 backgorund / border 一致的，而且它们的作用也是一致的，只不过 <code>background-*</code> 用在背景上，而 <code>mask-*</code> 用在遮罩层上而已——用在背景上的奇技淫巧搬到 mask 的世界里还能接着用！比如实现这样的效果：</p>
<p><img src="/2019/02/22/%E7%94%A8%E7%BA%AFCSS%E5%AE%9E%E7%8E%B0%E9%95%82%E7%A9%BA%E6%95%88%E6%9E%9C/16915c51b6c3daab.png"></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.masked</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: /* ... */;</span><br><span class="line">  <span class="attribute">width</span>: /* ... */;</span><br><span class="line">  <span class="attribute">background</span>: /* ... */;</span><br><span class="line">  <span class="comment">/* Webkit 内核用户请注意添加厂商前缀 -webkit */</span></span><br><span class="line">  <span class="attribute">mask</span>-image: <span class="built_in">url</span>(<span class="string">https://github.githubassets.com/pinned-octocat.svg</span>);</span><br><span class="line">  <span class="attribute">mask</span>-size: <span class="number">5em</span>;</span><br><span class="line">  <span class="attribute">mask</span>-<span class="attribute">position</span>: center;</span><br><span class="line">  <span class="comment">/* 如果你心情好，加个动画也没问题的 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="进一步控制遮罩效果"><a href="#进一步控制遮罩效果" class="headerlink" title="进一步控制遮罩效果"></a>进一步控制遮罩效果</h2><p>可能读者已经发现了，<code>mask-*</code> 家族里有几张生面孔。这也好理解： mask 这么强大的特性，完完全全地抄 <code>background-*</code> 岂不可惜了。</p>
<h3 id="mask-mode"><a href="#mask-mode" class="headerlink" title="mask-mode"></a><code>mask-mode</code></h3><p>mask-mode 用来指定具体的遮罩方式。</p>
<blockquote>
<p><strong>兼容性预警</strong>：目前 <code>mask-mode</code> 仅 Firefox 53+ 支持。</p>
</blockquote>
<p>mask-type CSS 属性设置 <code>mask-image</code> 被用于“亮度型”的遮罩还是“不透明度”型的遮罩。<code>mask-mode: alaph</code> 表示使用不透明度（即alaph通道）作为 mask value，<code>mask-mode: luminance</code> 表示使用亮度值作为 mask value。</p>
<p>那，遮罩值 / mask value 又是什么？mask value 表示被遮罩的元素被遮罩的程度。mask value 越大，被遮罩区域会更偏向于显露，mask value 最大的时候，那个区域就完全不透明了。举个例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mode&quot;</span>&gt;</span>ABCDEFG<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.mode</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="comment">/* and more */</span></span><br><span class="line">  <span class="attribute">mask</span>-image: <span class="built_in">linear-gradient</span>(to left, black, yellow);</span><br><span class="line">  <span class="attribute">mask</span>-mode: luminance; <span class="comment">/* or alaph ? */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/22/%E7%94%A8%E7%BA%AFCSS%E5%AE%9E%E7%8E%B0%E9%95%82%E7%A9%BA%E6%95%88%E6%9E%9C/16915cc34f589f22.png"></p>
<p>左边是遮罩图片，中间是 <code>luminance</code> 右边使用 <code>alaph</code>。这里的图片是不透明的，所以将一个恒不透明的图片在<code>alaph</code>模式下作为遮罩，其结果是没有遮罩效果。但是图片是有亮度变化的，所以<code>luminance</code>下的被遮罩元素就呈现出透明度的变化了。 </p>
<p>一般 <code>luminance</code> 模式慢一点点，因为每一个像素点的亮度值需要根据 RGB 三个通道的值计算出来。</p>
<h3 id="mask-composite"><a href="#mask-composite" class="headerlink" title="mask-composite"></a><code>mask-composite</code></h3><p>指定当有多个遮罩图片叠加起来的时候，如何处理遮罩效果。一些属性值的效果依赖于 mask-image 的层级次序。</p>
<p>用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/CSS/mask-composite#Example">MDN 提供的这个 CodePen</a> 来感受一下 </p>
<p>关于 <code>mask</code> 的知识就讲到这里，更具体更准确的说明还是<em>要到 MDN 看一看</em>。</p>
<h1 id="混合模式"><a href="#混合模式" class="headerlink" title="混合模式"></a>混合模式</h1><p>这应该是最为神奇的一种方法了。使用PS的时候，经常会看见“混合模式”这个词。还记得多年前我初次使用 Photoshop 的时候还很好奇“混合模式”是什么东西，顿时让我对 Photoshop 充满了敬畏之情。不过，当年的敬畏归敬畏，现在这里说的“混合模式”还是蛮好理解的。</p>
<p>所谓的“混合模式”，是指当一种当层重叠时计算像素最终颜色值的方法。每种混合模式接收前景颜色值和背景颜色值（分别为顶部颜色和底部颜色）作为输入，执行一些计算并输出最后要显示在屏幕上的颜色值。最终的可见的颜色是对层中的每个重叠像素执行混合模式计算所得的结果。<strong>说白了，混合模式确定了把一层叠加到另一层上去会得到什么结果。</strong></p>
<p>在 CSS 中，可以使用 <code>mix-blend-mode</code> 来指定混合模式。</p>
<p>你可能会问了，平时也没有用什么“混合模式”这种东西，所以<code>blend-mode</code>的默认值是<code>none</code>吗？可不是。其实，这种最常见的 上层把下层“遮住”了的情况也属于一种混合模式，叫<code>normal</code>，它本质上是一种只保留前景颜色值而完全抛弃背景颜色值的混合模式。</p>
<p>这里我们只讨论实现镂空效果用到的混合模式 —— <code>screen</code>。这种混合模式有一个特性，前景层是黑色导致最终可见的颜色直接是背景层的颜色，前景层是白色导致最终可见的颜色直接是白色。</p>
<p>相信你已经搞不明白这和镂空有什么关系了，下面举个例子看一下。</p>
<p>现在，我们有一个<code>&lt;video&gt;</code>，以及一个“白底黑字”的Logo浮层。</p>
<p><img src="/2019/02/22/%E7%94%A8%E7%BA%AFCSS%E5%AE%9E%E7%8E%B0%E9%95%82%E7%A9%BA%E6%95%88%E6%9E%9C/16915a8b25d771d1.png"></p>
<p>我们在浮层框上加上下面的 CSS：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.logo</span> &#123;</span><br><span class="line">    <span class="comment">/* ... ... */</span></span><br><span class="line">    mix-blend-mode: screen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就变成了下面的样子：</p>
<p><img src="/2019/02/22/%E7%94%A8%E7%BA%AFCSS%E5%AE%9E%E7%8E%B0%E9%95%82%E7%A9%BA%E6%95%88%E6%9E%9C/16915ae4bf83ad55.png"><br><a target="_blank" rel="noopener" href="https://codepen.io/xuxinhang/pen/KJjBbP">去这个 Demo，看具体代码和效果</a></p>
<p>齿轮图标确实是变为镂空的了。不过，为什么呢？</p>
<p>先来明确一件事：把浮层置于视频之上，浮层是“前景”，视频是“背景”。先来看浮层的白色部分，因为把白色置于任何颜色之上都得到白色，所以白色部分被保留；而因为黑色置于任何颜色之上都得到下层的颜色，所以黑色部分呈现镂空效果。</p>
<p>但是这样的实现比较 Hack，因为这里只使用了黑白两色，如果使用其它的颜色作为浮层的 <code>background-color</code>，得到的就不会像是镂空的效果了，这时还是得请上面的<code>mask</code>家族出场。不过，单单对于白底的情况，<code>mix-blend-mode</code> 不失为一个可行的解法。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/02/22/%E7%94%A8%E7%BA%AFCSS%E5%AE%9E%E7%8E%B0%E9%95%82%E7%A9%BA%E6%95%88%E6%9E%9C/" data-id="ckm7t0sp8000rgkugca200r0d" data-title="用纯 CSS 实现镂空效果" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/blend-mode/" rel="tag">blend mode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mask/" rel="tag">mask</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F/" rel="tag">混合模式</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%95%82%E7%A9%BA/" rel="tag">镂空</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-使用Heroku或OpenShift搭建自己的免费科学上网V2Ray服务" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/02/12/%E4%BD%BF%E7%94%A8Heroku%E6%88%96OpenShift%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%85%8D%E8%B4%B9%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91V2Ray%E6%9C%8D%E5%8A%A1/" class="article-date">
  <time class="dt-published" datetime="2019-02-12T14:16:40.000Z" itemprop="datePublished">2019-02-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/02/12/%E4%BD%BF%E7%94%A8Heroku%E6%88%96OpenShift%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%85%8D%E8%B4%B9%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91V2Ray%E6%9C%8D%E5%8A%A1/">使用 Heroku 或 OpenShift 搭建自己的免费科学上网 V2Ray 服务</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="使用-Heroku-或-OpenShift-搭建自己的免费科学上网-V2Ray-服务"><a href="#使用-Heroku-或-OpenShift-搭建自己的免费科学上网-V2Ray-服务" class="headerlink" title="使用 Heroku 或 OpenShift 搭建自己的免费科学上网 V2Ray 服务"></a>使用 Heroku 或 OpenShift 搭建自己的免费科学上网 V2Ray 服务</h1><h2 id="选择一款墙外的云服务"><a href="#选择一款墙外的云服务" class="headerlink" title="选择一款墙外的云服务"></a>选择一款墙外的云服务</h2><h3 id="如果有点钱：买一个云"><a href="#如果有点钱：买一个云" class="headerlink" title="如果有点钱：买一个云"></a>如果有点钱：买一个云</h3><p>这里还是推荐使用付费的云服务器，因为它的性能更加稳定，而且有良好的技术支持。只要所选的服务器位于墙外的网络上就可以。</p>
<h3 id="蓐羊毛：使用免费云"><a href="#蓐羊毛：使用免费云" class="headerlink" title="蓐羊毛：使用免费云"></a>蓐羊毛：使用免费云</h3><p>如果不想出这笔钱，也可选择境外的免费云服务。这里选择的是 Heroku 和 OpenShift，而且也<strong>不需要信用卡</strong>认证。这两个网站的登录、注册和管理页面需要翻墙才能进入。所以，需要提前备一个翻墙服务，直到完成服务器的部署。</p>
<p>免费的服务一般速度会比较慢，延迟高，而且也不稳定。如果你需要快速、更稳定的翻墙服务就不要在这上面打主意了，买一个靠谱的云服务吧！</p>
<h3 id="使用-Heroku"><a href="#使用-Heroku" class="headerlink" title="使用 Heroku"></a>使用 Heroku</h3><ol>
<li><p>进入 <a target="_blank" rel="noopener" href="https://heroku.com/">Heroku</a>，注册一个账户，登录。可能需要翻墙才能进入注册页面。</p>
</li>
<li><p>进入管理页面， <code>New</code> -&gt; <code>Create New App</code>   选择服务器位置，选择 “Europe” 还是 “US” 看自己，可以都试一试。</p>
</li>
<li><p>进入新建的 App，“Settings”中，添加一个环境变量 “<code>V2RAY_CONFIG_JSON</code>”，内容为你的 JSON 配置内容。（这里的 value 框可以输入多行，这个设计很不错！）</p>
</li>
<li><p>进入“Deploy”，选择使用“Heroku CLI”，照网页上的指导进行操作，完成部署。</p>
<blockquote>
<p>另外也有几个命令值得关注：</p>
<p><code>heroku git:remote</code> - 添加 remote 到现有的仓库 <a target="_blank" rel="noopener" href="https://devcenter.heroku.com/articles/heroku-cli-commands#heroku-git-remote">Link</a></p>
<p>…</p>
<p>更详细的步骤可见 <a target="_blank" rel="noopener" href="https://devcenter.heroku.com/articles/getting-started-with-nodejs#deploy-the-app">Deploy the app</a></p>
</blockquote>
<p> 一般来说，只要一 push，部署过程就会自动执行。</p>
</li>
</ol>
<h4 id="服务端配置示例"><a href="#服务端配置示例" class="headerlink" title="服务端配置示例"></a>服务端配置示例</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;log&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;error&quot;</span>: <span class="string">&quot;./error.log&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;loglevel&quot;</span>: <span class="string">&quot;warning&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;inbounds&quot;</span>: [&#123;</span><br><span class="line">    <span class="attr">&quot;port&quot;</span>: <span class="string">&quot;env:PORT&quot;</span>,           <span class="comment">// 要监听的端口使用环境变量定义的值</span></span><br><span class="line">    <span class="attr">&quot;listen&quot;</span>: <span class="string">&quot;0.0.0.0&quot;</span>,          <span class="comment">// 监听来自所有网络的流量</span></span><br><span class="line">    <span class="attr">&quot;protocol&quot;</span>: <span class="string">&quot;shadowsocks&quot;</span>,    <span class="comment">// 使用 SS 协议</span></span><br><span class="line">    <span class="attr">&quot;settings&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;method&quot;</span>: <span class="string">&quot;aes-256-cfb&quot;</span>,    <span class="comment">// 加密方式</span></span><br><span class="line">      <span class="attr">&quot;password&quot;</span>: <span class="string">&quot;your_password&quot;</span> <span class="comment">// 你自己的密码</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;streamSettings&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;network&quot;</span>:<span class="string">&quot;ws&quot;</span>              <span class="comment">// 使用 WebSocket 作为传输协议</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;],</span><br><span class="line">  <span class="attr">&quot;outbounds&quot;</span>: [&#123;</span><br><span class="line">    <span class="attr">&quot;protocol&quot;</span>: <span class="string">&quot;freedom&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;settings&quot;</span>: &#123;&#125;</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h4><ul>
<li><p>Heroku 貌似只允许  HTTP 和 WebSocket 协议访问。</p>
</li>
<li><p>Heroku 的免费版服务30 分钟无流量会进入休眠状态，之后再次有访问就会再唤醒服务。但是唤醒是需要时间的。这会表现为首次访问的卡顿。这是服务提供方的限制。可以使用网上的定时访问服务来实现 30 分钟做一次 HTTP 访问，阻止休眠。</p>
<blockquote>
<p>可到 <a target="_blank" rel="noopener" href="https://uptimerobot.com/">https://uptimerobot.com/</a> 设置每5分钟访问一次你的heroku app网址，防休眠。</p>
</blockquote>
</li>
<li><p>每个 Heroku 账户一共有 550 小时的免费服务使用时间（认证账户有 1000 小时）。如果你的账户只有一个 V2Ray 的服务，一个月 550 小时应该够用了。</p>
<blockquote>
<p>Heroku 免费账户的限制可见 <a target="_blank" rel="noopener" href="https://www.heroku.com/pricing">https://www.heroku.com/pricing</a></p>
</blockquote>
</li>
<li><p>V2Ray 运行起来后，访问服务地址应有 “Bad Request” 字样。（服务地址可用 “Open app” 按钮来打开。）如果没有，可能是 V2Ray 程序未启动。此时应 使用 “More” -&gt; “Run Console” 手动运行 <code>./Procfile</code> 的 <code>web:</code> 后的脚本。</p>
<blockquote>
<p>Procfile 的编写可见 <a target="_blank" rel="noopener" href="https://devcenter.heroku.com/articles/procfile">https://devcenter.heroku.com/articles/procfile</a> </p>
</blockquote>
</li>
</ul>
<h4 id="如果要修改代码"><a href="#如果要修改代码" class="headerlink" title="如果要修改代码"></a>如果要修改代码</h4><ul>
<li><code>PORT</code> 环境变量是由 Heroku 自定的，代表 Heroku 对我们暴露的端口。配置中可以用 <code>&quot;port&quot;: &quot;env:PORT&quot;</code>   来将 <code>PORT</code> 环境变量作为服务端 <code>port</code> 的配置。Heroku 做了端口映射，这里的 <code>PORT</code> 对应 Heroku App 对外的 80 端口。<a target="_blank" rel="noopener" href="https://devcenter.heroku.com/articles/runtime-principles#web-servers">见这里</a></li>
<li>…</li>
</ul>
<h3 id="使用-OpenShift"><a href="#使用-OpenShift" class="headerlink" title="使用 OpenShift"></a>使用 OpenShift</h3><ol>
<li><p>GitHub 上新建自己的代码仓库，将代码提交到上面</p>
</li>
<li><p>注册账户，登录，选择使用 Starter Plan。进入 Starter Plan 的控制台。（可能需要翻墙才能进入注册页面。）</p>
</li>
<li><p>新建一个 Project ，进入，选 “Browser Catalog” -&gt; “Node.js” 。 “Git Respository” 填入你的仓库地址。点 “Create”。</p>
</li>
<li><p>现在，OpenShift 应该已经迫不及待地先拉取代码，Build，再 Deploy 了。</p>
</li>
<li><p>但是，还有几步要做。配置环境变量：</p>
<ul>
<li>进入 “Overview” ，在 Application - Deploy Config 下，点击三个点 -&gt; “Edit”</li>
<li>“Environment Variables” 下新增两个环境变量，保存：<ul>
<li><code>V2RAY_CONFIG_JSON</code> ：填写 V2Ray 配置，只能填一行。填入的内容要符合 JSON 格式，<em>注意剔除注释</em>。</li>
<li><code>PORT</code>：指定 inbound 端口，这里是 “8080”。（和 “Application” -&gt; “Routes” 下的配置一致。）</li>
</ul>
</li>
</ul>
</li>
<li><p>调整路由：</p>
<ul>
<li>前往 “Overview” - &lt;你的Application名称&gt; - “Networking”。</li>
<li>未配置路由请点击 “Create Route” 。已配置路由则进入 “Application” -&gt; “Routes”，进入对应项目，执行 “Action” - “Edit”。</li>
<li>“Security” 下勾选 “Secure route”，保存。</li>
</ul>
</li>
<li><p>重新部署。 “Application” -&gt; “Deployment” -&gt; <em>&lt;你的Application名称&gt;</em> -&gt; 点 “Deploy” 按钮。 </p>
</li>
<li><p>如果你更新了代码仓库，想更新 Project，要先到 “Builds” -&gt; “Builds” 下进行构建，再到 “Application” -&gt; “Deploy” 做部署。</p>
</li>
<li><p>如果返回 Overview 界面能看到服务器地址了，那么服务端已经大功告成。直接访问服务的 HTTPS 地址应有 “Bad Request” 字样。</p>
</li>
</ol>
<h4 id="一些问题-1"><a href="#一些问题-1" class="headerlink" title="一些问题"></a>一些问题</h4><ul>
<li>OpenShift 免费的 Starter Plan <a target="_blank" rel="noopener" href="https://www.openshift.com/products/online/">亦有限制</a>：<ul>
<li>Starter Plan 下只许有一个 Project</li>
<li>同样在 30min 无活动后休眠，且每 72 小时内需有 18 小时的休眠时间。（如果你不是三天三夜不合眼翻墙，应该也够了。）</li>
<li>60 天之后自动过期，到时需 resubscribe 。</li>
</ul>
</li>
<li>不过 OpenShift 支持 TCP 直连，所以你也可使用性能更好的 TCP 传输协议而不是本仓库中用的 WebSocket。</li>
</ul>
<h4 id="如果你要修改代码"><a href="#如果你要修改代码" class="headerlink" title="如果你要修改代码"></a>如果你要修改代码</h4><ul>
<li>只有 Build 环节才可 <code>chmod</code>，一旦构建为 Image，部署后执行<code>chmod</code>是没有权限的。</li>
<li>默认在 Node.js 项目中，Build 过程调用 <code>npm build</code>；Deploy 过程调用 <code>npm start</code> 运行程序。</li>
<li>也可以使用自己的 Build / Deploy 脚本。参见 <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/46091601/cannot-chmod-file-on-OpenShift-online-v3-operation-not-permitted">Stackoverflow</a>。</li>
<li>…</li>
</ul>
<h4 id="服务端-V2Ray-配置示例"><a href="#服务端-V2Ray-配置示例" class="headerlink" title="服务端 V2Ray 配置示例"></a>服务端 V2Ray 配置示例</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 和 Heroku 的几乎完全一样，复制过去注意删去注释 */</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;log&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;error&quot;</span>: <span class="string">&quot;./error.log&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;loglevel&quot;</span>: <span class="string">&quot;warning&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;inbounds&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;port&quot;</span>: <span class="string">&quot;env:PORT&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;listen&quot;</span>: <span class="string">&quot;0.0.0.0&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;protocol&quot;</span>: <span class="string">&quot;shadowsocks&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;settings&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;method&quot;</span>: <span class="string">&quot;aes-256-cfb&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;password&quot;</span>: <span class="string">&quot;your_password&quot;</span>   <span class="comment">// 修改为你的密码</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;streamSettings&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;network&quot;</span>: <span class="string">&quot;ws&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;outbounds&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;protocol&quot;</span>: <span class="string">&quot;freedom&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;settings&quot;</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="V2Ray-客户端配置"><a href="#V2Ray-客户端配置" class="headerlink" title="V2Ray 客户端配置"></a>V2Ray 客户端配置</h2><h3 id="关于-V2Ray"><a href="#关于-V2Ray" class="headerlink" title="关于 V2Ray"></a>关于 V2Ray</h3><p>V2Ray 是新一代的科学上网利器。它更为小众，支持的协议也更多，更不容易被封禁。</p>
<p>V2Ray <strong>原生支持多协议</strong>，包括但不限于Socks、HTTP、Shadowsocks、VMess等；也支持使用 WebSocket，TCP，TLS 等<strong>多种传输协议进行传输</strong>。此外，V2Ray 内置灵活的路由，通过内置的路由功能，它可以灵活地实现选择性转发、直连或是阻止部分连接。对 DNS 服务也有基本的支持。</p>
<p>可见 <a target="_blank" rel="noopener" href="https://www.**v2ray**.com/">V2Ray 文档</a> 和 <a target="_blank" rel="noopener" href="https://toutyrater.github.io/">V2Ray 白话文教程</a></p>
<h6 id="本文为什么使用-V2Ray？"><a href="#本文为什么使用-V2Ray？" class="headerlink" title="本文为什么使用 V2Ray？"></a>本文为什么使用 V2Ray？</h6><p>因为 Heroku 只支持 HTTP 和 WebSocket 协议，所以原生支持 WebSocket 作为传输协议的 V2Ray 就是不二之选了。（OpenShift 貌似没这一限制。）</p>
<p>另外，需要注意的是，“协议”和“传输协议”是不一样的。“传输协议”是“协议”的载体。</p>
<h3 id="使用客户端"><a href="#使用客户端" class="headerlink" title="使用客户端"></a>使用客户端</h3><p>到 <a target="_blank" rel="noopener" href="https://github.com/v2ray/v2ray-core/releases">github.com/v2ray/v2ray-core</a> 下载 V2Ray，按照 V2Ray 文档所述运行。如果不指定 <code>-config</code> 参数，默认使用同目录下的 <code>config.json</code> 文件。</p>
<p>可以将配置文件保存为同目录下的 <code>config.json</code>， 然后直接运行 <code>v2ray</code>。</p>
<blockquote>
<p>Windows 下的 GUI 可使用 V2RayN </p>
<p>macOS GUI 可用 V2RayX </p>
<p>Android 下可使用 BifrostV、V2Ray Go、V2RayNG、Actinium</p>
<p>可见 <a target="_blank" rel="noopener" href="https://www.i5seo.com/v2ray-android-v2rayng-actinium-bifrostv-v2ray-go-actinium.html">这篇文章</a></p>
</blockquote>
<h4 id="客户端配置示例-Heroku"><a href="#客户端配置示例-Heroku" class="headerlink" title="客户端配置示例 (Heroku)"></a>客户端配置示例 (Heroku)</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;inbounds&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;port&quot;</span>: <span class="number">1081</span>,</span><br><span class="line">      <span class="attr">&quot;protocol&quot;</span>: <span class="string">&quot;socks&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;sniffing&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;enabled&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">&quot;destOverride&quot;</span>: [<span class="string">&quot;http&quot;</span>, <span class="string">&quot;tls&quot;</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;settings&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;auth&quot;</span>: <span class="string">&quot;noauth&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;outbounds&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;protocol&quot;</span>: <span class="string">&quot;shadowsocks&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;settings&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;servers&quot;</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">&quot;address&quot;</span>: <span class="string">&quot;your_app_name.herokuapp.com&quot;</span>, <span class="comment">// 域名，可在 Settings 中找到</span></span><br><span class="line">            <span class="attr">&quot;method&quot;</span>: <span class="string">&quot;aes-256-cfb&quot;</span>,                  <span class="comment">// 对应</span></span><br><span class="line">            <span class="attr">&quot;password&quot;</span>: <span class="string">&quot;your_password&quot;</span>,              <span class="comment">// 服务端配置中对应的密码</span></span><br><span class="line">            <span class="attr">&quot;port&quot;</span>: <span class="number">80</span>                                <span class="comment">// 默认 80 端口</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;streamSettings&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;network&quot;</span>:<span class="string">&quot;ws&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;mux&quot;</span>: &#123; <span class="attr">&quot;enabled&quot;</span>: <span class="literal">true</span> &#125;                      <span class="comment">// 多路复用</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="客户端配置示例-OpenShift"><a href="#客户端配置示例-OpenShift" class="headerlink" title="客户端配置示例 (OpenShift)"></a>客户端配置示例 (OpenShift)</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;inbounds&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;port&quot;</span>: <span class="number">1081</span>,</span><br><span class="line">      <span class="attr">&quot;protocol&quot;</span>: <span class="string">&quot;socks&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;sniffing&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;enabled&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">&quot;destOverride&quot;</span>: [<span class="string">&quot;http&quot;</span>, <span class="string">&quot;tls&quot;</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;settings&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;auth&quot;</span>: <span class="string">&quot;noauth&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;outbounds&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;tag&quot;</span>: <span class="string">&quot;OpenShift&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;protocol&quot;</span>: <span class="string">&quot;shadowsocks&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;settings&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;servers&quot;</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">&quot;address&quot;</span>: <span class="string">&quot;your.name.OpenShiftapps.com&quot;</span>, <span class="comment">// 域名，在 Overview 或 Routes 中找到</span></span><br><span class="line">            <span class="attr">&quot;method&quot;</span>: <span class="string">&quot;aes-256-cfb&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;password&quot;</span>: <span class="string">&quot;your_password&quot;</span>,              <span class="comment">// 服务端配置中对应的密码</span></span><br><span class="line">            <span class="attr">&quot;port&quot;</span>: <span class="number">443</span>                               <span class="comment">// wss 默认使用 433 端口</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;streamSettings&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;network&quot;</span>:<span class="string">&quot;ws&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;security&quot;</span>: <span class="string">&quot;tls&quot;</span>,          <span class="comment">// 对应服务端的设置，这里使用加密的 WebSocket 协议</span></span><br><span class="line">        <span class="attr">&quot;tlsSettings&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;allow Insecure&quot;</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;mux&quot;</span>: &#123; <span class="attr">&quot;enabled&quot;</span>: <span class="literal">true</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="浏览器连接到-V2Ray-客户端"><a href="#浏览器连接到-V2Ray-客户端" class="headerlink" title="浏览器连接到 V2Ray 客户端"></a>浏览器连接到 V2Ray 客户端</h3><p>自行 Google</p>
<p>配置要和客户端 <code>inbounds</code> 配置对应</p>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a target="_blank" rel="noopener" href="https://51.ruyo.net/1469.html">https://51.ruyo.net/1469.html</a></li>
<li><a target="_blank" rel="noopener" href="https://51.ruyo.net/1469.html">利用OpenShift搭建免(翻)费(墙)科技</a></li>
<li><a target="_blank" rel="noopener" href="https://51.ruyo.net/1461.html">利用Heroku搭建免费科学爬墙（亲测可行）</a></li>
<li><a target="_blank" rel="noopener" href="http://www.live-in.org/archives/1818.html">OpenShift使用方法介绍</a></li>
<li><a target="_blank" rel="noopener" href="https://51.ruyo.net/4023.html">OpenShift V3版操作使用指南-入门版（附福利）</a></li>
<li><a target="_blank" rel="noopener" href="http://suki.live/2018/10/25/%E4%BD%BF%E7%94%A8OpenShift%E7%9A%84%E5%85%8D%E8%B4%B9%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BAV2Ray/">使用OpenShift的免费服务器搭建V2Ray</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/wangyi2005/v2ray/issues/8#">openshift 部署 V2Ray  Websocket 服务端成功，客户端怎么弄，谢谢大神解惑！</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/onplus/shadowsocks-heroku/issues/57#">shadowsocks-heroku（美国）配合DnsJumper小公举，速度稳定在2M</a>  </li>
<li><a target="_blank" rel="noopener" href="https://xlesun.com/v2ray-1.html">Heroku部署免费的V2Ray节点</a></li>
<li><a target="_blank" rel="noopener" href="https://bbs.hupu.com/19816661.html">https://bbs.hupu.com/19816661.html</a></li>
<li><a target="_blank" rel="noopener" href="http://cyjun.win/2017/06/03/heroku%E9%83%A8%E7%BD%B2SS/">heroku部署SS</a></li>
<li><a target="_blank" rel="noopener" href="https://lsland.cn/Technical/OpenShift.html">【教程】使用OpenShift搭建V2ray出国旅游</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/02/12/%E4%BD%BF%E7%94%A8Heroku%E6%88%96OpenShift%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%85%8D%E8%B4%B9%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91V2Ray%E6%9C%8D%E5%8A%A1/" data-id="ckm7t0sox000dgkug5vin0ils" data-title="使用 Heroku 或 OpenShift 搭建自己的免费科学上网 V2Ray 服务" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/V2Ray/" rel="tag">V2Ray</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/" rel="tag">科学上网</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-剖析-HTTPS-的设计思路" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/01/11/%E5%89%96%E6%9E%90-HTTPS-%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/" class="article-date">
  <time class="dt-published" datetime="2019-01-11T15:13:38.000Z" itemprop="datePublished">2019-01-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/01/11/%E5%89%96%E6%9E%90-HTTPS-%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/">剖析 HTTPS 的设计思路</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer ，安全的超文本传输协议），是以安全为目标的HTTP通道。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。这个系统的最初研发由 Netscape 进行。</p>
<p>如今，HTTPS 已经渐渐成为主流，很多大型网站都已经全站 HTTPS 化。那么有了 HTTP 后为什么还需要有 HTTPS 呢？——为了解决 HTTP 的不足。</p>
        
          <p class="article-more-link">
            <a href="/2019/01/11/%E5%89%96%E6%9E%90-HTTPS-%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/01/11/%E5%89%96%E6%9E%90-HTTPS-%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/" data-id="ckm7t0sp1000hgkugbo2dcr1e" data-title="剖析 HTTPS 的设计思路" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTPS/" rel="tag">HTTPS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/" rel="tag">密码学</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Pro-Git-Tips" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/12/12/Pro-Git-Tips/" class="article-date">
  <time class="dt-published" datetime="2018-12-12T14:16:40.000Z" itemprop="datePublished">2018-12-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/12/12/Pro-Git-Tips/">Pro Git Tips</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Tips-amp-Summaries-for-Pro-Git"><a href="#Tips-amp-Summaries-for-Pro-Git" class="headerlink" title="Tips &amp; Summaries for Pro Git"></a>Tips &amp; Summaries for <em>Pro Git</em></h1><p>The notes for <em>Pro Git</em>. Written By Cattle with :heart:</p>
<h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><ul>
<li><input disabled="" type="checkbox"> git rm</li>
<li><input disabled="" type="checkbox"> git push 各种参数 + 高级用法</li>
<li><input disabled="" type="checkbox"> git revert</li>
</ul>
<h2 id="1-6-起步-初次运行-Git-前的配置"><a href="#1-6-起步-初次运行-Git-前的配置" class="headerlink" title="1.6 起步 - 初次运行 Git 前的配置"></a>1.6 起步 - 初次运行 Git 前的配置</h2><p>Git 的分级配置：</p>
<ol>
<li><code>/etc/gitconfig</code> 文件: 包含系统上每一个用户及他们仓库的通用配置。 使用 <code>git config --system</code> </li>
<li><code>~/.gitconfig</code> 或 <code>~/.config/git/config</code> 文件：只针对当前用户。 可以传递 <code>--global</code> 选项让 Git 读写此文件。</li>
<li>当前使用仓库的 Git 目录中的 <code>config</code> 文件（就是 <code>.git/config</code>）：针对该仓库。</li>
</ol>
<p>每一个级别覆盖上一级别的配置。</p>
<h2 id="1-3-起步-Git-基础"><a href="#1-3-起步-Git-基础" class="headerlink" title="1.3 起步 - Git 基础"></a>1.3 起步 - Git 基础</h2><ul>
<li><p>Git 更像是把数据看作是<strong>对小型文件系统的一组快照</strong>。每次你提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。</p>
</li>
<li><p>Git 中所有数据在存储前都计算校验和，然后以校验和来引用——不可能在 Git 不知情时更改任何文件内容或目录内容。</p>
</li>
<li><p>Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。</p>
</li>
<li><p>你执行的 Git 操作，几乎只往 Git 数据库中增加数据。很难让 Git 执行任何不可逆操作，或者让它以任何方式清除数据。一旦你提交快照到 Git 中，就难以再丢失数据。</p>
</li>
</ul>
<p>你的文件可能处于<strong>三种状态之一</strong>：:star:</p>
<table>
<thead>
<tr>
<th>Which</th>
<th></th>
<th>Where</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>已提交 commited</td>
<td>已经安全的保存在本地数据库中。</td>
<td>Git 仓库 Repository</td>
<td>保存项目的元数据和对象数据库的地方，是最重要的部分。</td>
</tr>
<tr>
<td>已暂存 staged</td>
<td>对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</td>
<td>暂存区（索引）</td>
<td>一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。</td>
</tr>
<tr>
<td>已修改 modified</td>
<td>修改了文件，但还没保存到数据库中。</td>
<td>工作目录</td>
<td>对项目的某个版本独立提取出来的内容，供你使用或修改。</td>
</tr>
</tbody></table>
<h2 id="2-2-Git-基础-记录每次更新到仓库"><a href="#2-2-Git-基础-记录每次更新到仓库" class="headerlink" title="2.2 Git 基础 - 记录每次更新到仓库"></a>2.2 Git 基础 - 记录每次更新到仓库</h2><p><strong>你工作目录下的每一个文件都不外乎这两种状态：已跟踪或未跟踪。</strong></p>
<ul>
<li>已跟踪的文件是指那些被纳入了版本控制的文件，<strong>它们的状态可能处于未修改，已修改或已放入暂存区</strong>。</li>
<li>其它文件都属于未跟踪文件，它们既不存在于上次快照的记录中，<strong>也没有放入暂存区</strong>。</li>
</ul>
<p><img src="/2018/12/12/Pro-Git-Tips/lifecycle.png" alt="Git 下文件生命周期图。"></p>
<p><em>Figure 1. 文件的状态变化周期</em> :star:</p>
<p><strong><code>git status</code></strong></p>
<p><code>git status -s</code> 命令或 <code>git status --short</code> 命令，更为紧凑的格式输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">M README         # 左M：被修改且在暂存区</span><br><span class="line">MM Rakefile      # 右M：被修改但未暂存</span><br><span class="line">A  lib&#x2F;git.rb    # 新添加到暂存区中</span><br><span class="line">?? LICENSE.txt   # 未跟踪文件</span><br></pre></td></tr></table></figure>
<p>匹配模式以（<code>/</code>）结尾指定目录。要忽略以外的文件或目录，在模式前加上惊叹号（<code>!</code>）。</p>
<p><strong><code>git diff</code></strong></p>
<ul>
<li><p>要查看<strong>尚未暂存的文件</strong>更新了哪些部分，不加参数直接输入 <code>git diff</code></p>
</li>
<li><p>若要查看已暂存的内容，可以用 <code>git diff --cached</code>or <code>--staged</code> 命令。</p>
</li>
<li><p>请注意，<code>git diff</code> <strong>本身只显示尚未暂存的</strong>改动，<strong>而不是</strong>自上次提交以来所做的所有改动。</p>
</li>
<li><p>使用 <code>git difftool</code> 命令 - Git Diff 插件。    <code> --tool-help</code> </p>
</li>
</ul>
<p><strong><code>git commit</code></strong></p>
<p>更详细的对修改了哪些内容的提示? 可以用 <code>-v</code> 选项，这会将改变的 diff 输出放到编辑器</p>
<p><code>git commit -a</code> ，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交.</p>
<p><strong><code>git rm</code></strong>   [不带参数] 从工作区删除 + 从暂存区删除（标记为删除）</p>
<p><code>git rm --cached </code>  从仓库删除，不想让 Git 继续跟踪，但保留文件。</p>
<p>不像其它的 VCS 系统，Git 并不显式跟踪文件移动操作，但它会推断出改名操作。运行 <code>git mv</code> 就相当于运行了下面三条命令：<em>（语法糖？）</em></p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mv README.md README</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rm README.md</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add README</span></span><br></pre></td></tr></table></figure>


<h2 id="2-3-Git-基础-查看提交历史"><a href="#2-3-Git-基础-查看提交历史" class="headerlink" title="2.3 Git 基础 - 查看提交历史"></a>2.3 Git 基础 - 查看提交历史</h2><p><strong><code>git log</code></strong></p>
<p><code>-p -2 --stat --pretty=oneline|short|full|fuller</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git log -&lt;n&gt;               # 仅最近的n条提交</span><br><span class="line">$ git log --since&#x3D;2.weeks    # 按时间</span><br><span class="line">$ git log --until&#x3D;2 years 1 day 3 minutes ago</span><br><span class="line">$ git log -S function_name   # 添加或移除了某些字符串的提交</span><br><span class="line">                             # (例如：添加或移除了某一个特定函数的引用的提交)</span><br><span class="line">$ git log -- &lt;path&gt;          # 指定的文件或目录</span><br></pre></td></tr></table></figure>
<p>用 <code>--author</code> 选项显示指定作者的提交，用 <code>--grep</code> 选项搜索提交说明中的关键字。</p>
<p>如果要得到<strong>同时满足这两个</strong>选项搜索条件的提交，就<strong>必须用</strong> <code>--all-match</code> 选项。</p>
<p>【举例】 <code>git log --oneline --decorate --graph --all</code> ，它会输出你的提交历史、各个分支的指向以及项目的分支分叉情况。</p>
<p>灵活使用参数，提高生产力！</p>
<table>
<thead>
<tr>
<th>选项:star:</th>
<th>说明</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>-p</code></td>
<td>按补丁(diff)格式显示每个更新之间的差异。</td>
<td><code>diff --git a/.babelrc b/.babelrc</code></td>
</tr>
<tr>
<td><code>--stat</code></td>
<td>显示每次更新的文件修改统计信息。:star:</td>
<td></td>
</tr>
<tr>
<td><code>--shortstat</code></td>
<td>只显示 –stat 中最后的行数修改添加移除统计。</td>
<td><code>48 files changed, 7835 insertions(+)</code></td>
</tr>
<tr>
<td><code>--name-only</code></td>
<td>仅在提交信息后显示已修改的文件清单。</td>
<td></td>
</tr>
<tr>
<td><code>--name-status</code></td>
<td>显示新增、修改、删除的文件清单。</td>
<td></td>
</tr>
<tr>
<td><code>--abbrev-commit</code></td>
<td>仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。</td>
<td></td>
</tr>
<tr>
<td><code>--relative-date</code></td>
<td>使用较短的相对时间显示（比如，“2 weeks ago”）。</td>
<td></td>
</tr>
<tr>
<td><code>--graph</code></td>
<td>:star:显示 ASCII 图形表示的分支合并历史。</td>
<td></td>
</tr>
<tr>
<td><code>--pretty</code></td>
<td>使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。<br /><a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/ch00/rpretty_format"><code>git log --pretty=format</code> 常用的选项</a> 列出了常用的格式占位符写法及其代表的意义。</td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p><em>作者</em> 和 <em>提交者</em> 之间究竟有何差别，<br>其实作者指的是实际作出修改的人，提交者指的是最后将此工作成果提交到仓库的人。所以，当你为某个项目发布补丁，然后某个核心成员将你的补丁并入项目时，你就是作者，而那个核心成员就是提交者。</p>
</blockquote>
<h2 id="2-4-Git-基础-撤消操作"><a href="#2-4-Git-基础-撤消操作" class="headerlink" title="2.4 Git 基础 - 撤消操作"></a>2.4 Git 基础 - 撤消操作</h2><ul>
<li>都知道的：</li>
</ul>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -a 是 --all 的缩写</span></span><br></pre></td></tr></table></figure>
<ul>
<li>取消暂存 <code>CONTRIBUTING.md</code> 文件<br> 同时看“重置揭秘”，加深理解。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD CONTRIBUTING.md</span><br></pre></td></tr></table></figure>
<p>不加选项地调用 <code>git reset</code> 并不危险 — 它只会修改暂存区域。</p>
<ul>
<li>如何撤消之前所做的修改。</li>
</ul>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- CONTRIBUTING.md</span><br><span class="line"><span class="meta">#</span><span class="bash"> 不需要 --hard 之类哦。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这是危险的命令。除非你确实不想要那个文件</span></span><br></pre></td></tr></table></figure>
<p>记住，在 Git 中任何 <em>已提交的</em> 东西几乎总是可以恢复的。</p>
<h2 id="2-5-Git-基础-远程仓库的使用"><a href="#2-5-Git-基础-远程仓库的使用" class="headerlink" title="2.5 Git 基础 - 远程仓库的使用"></a>2.5 Git 基础 - 远程仓库的使用</h2><p><code>git fetch [remote-name]</code>访问远程仓库，从中拉取所有你还没有的数据。<strong>必须注意</strong>它并不会自动合并或修改你当前的工作。</p>
<p>如果你有一个分支设置为跟踪一个远程分支可使用 <code>git pull</code> 命令来自动的抓取然后合并远程分支到当前分支。<br>运行 <code>git pull</code> 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。</p>
<p><code>git push origin master</code></p>
<p>更多 <code>git remote</code>的操作：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote      <span class="comment"># 列出远端的列表</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote -v   <span class="comment"># 同上，但查看更详细信息</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote show [remote-name]   <span class="comment"># 更多信息，可以使用</span></span> </span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote add pb https://github.com/paulboone/ticgit</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote rename pb paul</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote rm paul</span></span><br></pre></td></tr></table></figure>


<h2 id="2-6-Git-基础-打标签"><a href="#2-6-Git-基础-打标签" class="headerlink" title="2.6 Git 基础 - 打标签"></a>2.6 Git 基础 - 打标签</h2><ul>
<li>列出已有标签  <code>git tag</code></li>
<li>列出具体的？  <code>git tag -l &#39;v1.8.*&#39; </code>     <code> (-l = --list)</code></li>
</ul>
<p>两种主要类型的标签：轻量标签（lightweight）与附注标签（annotated）。</p>
<p><strong>附注标签</strong>（a = annotation）</p>
<p>附注标签是存储在 Git 数据库中的一个完整对象。它们是可以被校验的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a v1.4 -m &#39;my version 1.4&#39;</span><br></pre></td></tr></table></figure>
<p><code>-m</code> 选项指定了一条将会存储在标签中的信息。如果没有为附注标签指定一条信息，Git 会运行编辑器要求你输入信息（就像<code>git commit</code>）。</p>
<p><strong>轻量标签</strong></p>
<p>轻量标签本质上是将提交校验和存储到一个文件中，没有其他信息。只需要提供标签名字：<code>$ git tag v1.4-lw</code></p>
<p>也可在命令之后指定一个引用（默认是当前 / HEAD）。</p>
<p><strong>共享标签</strong></p>
<p>在创建完标签后你必须<strong>显式地推送</strong>标签到共享服务器上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin [tagname]</span><br><span class="line"># 或者，想一次性推送很多标签？</span><br><span class="line">$ git push origin --tags</span><br></pre></td></tr></table></figure>
<h2 id="2-7-Git-基础-Git-别名"><a href="#2-7-Git-基础-Git-别名" class="headerlink" title="2.7 Git 基础 - Git 别名"></a>2.7 Git 基础 - Git 别名</h2><p>设置 Git 别名：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --global alias.co checkout</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global alias.last <span class="string">&#x27;log -1 HEAD&#x27;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 想要执行外部命令，而不是一个 Git 命令？前面加入 ! 符号。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global alias.visual <span class="string">&#x27;!gitk&#x27;</span></span></span><br></pre></td></tr></table></figure>


<h2 id="3-1-Git-分支-分支简介"><a href="#3-1-Git-分支-分支简介" class="headerlink" title="3.1 Git 分支 - 分支简介"></a>3.1 Git 分支 - 分支简介</h2><blockquote>
</blockquote>
<p>Git 分支本质上仅仅是指向提交对象的可变指针（包含所指对象校验和的文件），它在每次的提交操作中自动向前移动。</p>
<p>它有一个名为 <code>HEAD</code> 的特殊指针。（和许多其它版本控制系统里的 <code>HEAD</code> 概念完全不同。）</p>
<p>Git是怎么知道当前在哪一个分支上呢？Git 使用名为 <code>HEAD</code> 的特殊指针，它指向当前所在的本地分支。</p>
<p>:notebook:HEAD可以指向一个分支引用，分支又指向一次提交。<em>看看“Git内部原理”加深理解</em>。</p>
<blockquote>
<p> Git 的分支实质上仅是包含所指对象校验和（SHA-1 值字符串）的文件，所以它的创建和销毁都异常高效。</p>
<p>当使用 <code>git commit</code> 进行提交操作时，Git 会先计算每一个子目录（本例中只有项目根目录）的校验和，然后在 Git 仓库中这些校验和保存为树对象。随后，Git 便会创建一个提交对象，它除了包含上面提到的那些信息外，还包含指向这个树对象（项目根目录）的指针。</p>
</blockquote>
<p>运行 <code>git log --oneline --decorate --graph --all</code> ，它会输出你的提交历史、各个分支的指向以及项目的分支分叉情况。</p>
<h2 id="3-2-Git-分支-分支的新建与合并"><a href="#3-2-Git-分支-分支的新建与合并" class="headerlink" title="3.2 Git 分支 - 分支的新建与合并"></a>3.2 Git 分支 - 分支的新建与合并</h2><p><strong>快进（fast-forward）</strong>合并：由于当前 <code>master</code> 分支所指向的提交是你当前提交的直接上游（合并操作没有需要解决的分歧），所以 Git 只是简单的将指针向前移动。</p>
<p><strong>删除分支</strong>：<code>git branch -d &lt;branch_name&gt;</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">C0 --&gt; C1</span><br><span class="line">C1 --dev--&gt; C2</span><br><span class="line">C2 --&gt; M[Fast-forward &lt;br&gt; Merge]</span><br><span class="line">C1 --master--&gt; M</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>三方合并</strong>：开发历史从一个更早的地方分叉<em>diverged</em>。Git 会使用两个分支的末端所指的快照（<code>C4</code> 和 <code>C5</code>）以及这两个分支的工作祖先（<code>C2</code>），做一个简单的三方合并。自动创建一个有<strong>不止一个父提交的新的提交</strong>。</p>
<blockquote>
<p> “三方” 指合并的已方、他方和它们的共同祖先。  <a target="_blank" rel="noopener" href="https://gqqnbig.me/2017/08/20/%e7%89%88%e6%9c%ac%e6%8e%a7%e5%88%b6%e4%b8%ad%e7%9a%84%e4%b8%89%e6%96%b9%e5%90%88%e5%b9%b6/">这篇文章</a> 解释了共同祖先对于分支合并是非常重要的。“没有共同祖先，我们就难以确定如何合并，遑论机器了。”</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">graph RL</span><br><span class="line"></span><br><span class="line">C1 --&gt; C0</span><br><span class="line">C2 --&gt; C1</span><br><span class="line">C4 --&gt; C2(&lt;b&gt;C2&lt;&#x2F;b&gt;&lt;br&gt;&lt;small&gt; Common &lt;br&gt; Ancestor&lt;&#x2F;small&gt;)</span><br><span class="line">C5 --&gt; C3</span><br><span class="line">C3 --&gt; C2</span><br><span class="line"></span><br><span class="line">M&#123;M&#125; -.-|master| C4</span><br><span class="line">M&#123;M&#125; -.-|dev| C5</span><br><span class="line"></span><br><span class="line">class C4,C5,C2 ref;</span><br><span class="line">classDef ref stroke:blue,stroke-width:3px;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="遇到冲突时"><a href="#遇到冲突时" class="headerlink" title="遇到冲突时"></a>遇到冲突时</h5><ol>
<li>Git 会在有冲突的文件中加入标准的冲突解决标记。</li>
<li>手动编辑，解决冲突。</li>
<li>使用 <code>git status</code> 命令来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件。</li>
<li>对每个文件使用 <code>git add</code> 命令来将其标记为冲突已解决。</li>
<li><code>git commit</code> 来完成合并提交。</li>
<li>图形化工具？ <code>git mergetool</code>（可自定义，见“配置”章节）。</li>
</ol>
<h2 id="3-3-Git-分支-分支管理"><a href="#3-3-Git-分支-分支管理" class="headerlink" title="3.3 Git 分支 - 分支管理"></a>3.3 Git 分支 - 分支管理</h2><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch              <span class="comment"># 列出当前所有分支</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -v           <span class="comment"># 查看每一个分支的最后一次提交</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch --merged     <span class="comment"># 列出已经合并到当前分支的分支</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch --no-merged  <span class="comment"># 包含未合并工作的分支</span></span></span><br></pre></td></tr></table></figure>
<p> <code>git branch -d</code> 命令删除未合并的分支会失败。<code>-D</code>来强制删。</p>
<h2 id="3-4-Git-分支-分支开发工作流"><a href="#3-4-Git-分支-分支开发工作流" class="headerlink" title="3.4 Git 分支 - 分支开发工作流"></a>3.4 Git 分支 - 分支开发工作流</h2><blockquote>
<p>To: Appendix 1</p>
</blockquote>
<h2 id="3-5-Git-分支-远程分支"><a href="#3-5-Git-分支-远程分支" class="headerlink" title="3.5 Git 分支 - 远程分支"></a>3.5 Git 分支 - 远程分支</h2><p>远程分支以 <code>(remote)/(branch)</code> 形式命名。只要你不与 origin 服务器连接，你的<code>origin/master</code> 指针就不会移动。</p>
<p>运行 <code>git fetch teamone</code> 来抓取远程仓库 <code>teamone</code> 有而本地没有的数据。</p>
<p>要公开分享一个分支？<strong>本地的分支并不会自动与远程仓库同步</strong>，运行 <code>git push (remote) (branch)</code>：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin serverfix</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin serverfix:anotherfix  <span class="comment"># 两边使用不同的标签名</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin  <span class="comment"># 设定了上游分支之后就不必写分支名了</span></span></span><br></pre></td></tr></table></figure>
<p>Git 自动将 <code>serverfix</code> 分支名字<strong>展开为</strong> <code>refs/heads/serverfix:refs/heads/serverfix</code>。也可以使用不同的分支名字，例如运行<code>git push origin serverfix:awesomebranch</code> 来将本地的 <code>serverfix</code> 分支推送到远程仓库上的 <code>awesomebranch</code> 分支。</p>
<ul>
<li><p><input disabled="" type="checkbox">  What’s ref/heads ?</p>
<p><code>ref/heads/master</code> &lt;=&gt; <code>.git/ref/heads/master</code></p>
<blockquote>
<p>参见“Git 引用”这一章</p>
</blockquote>
</li>
</ul>
<p>下一次其他协作者从服务器上抓取数据时，他们会在本地生成一个远程分支 <code>origin/serverfix</code>，指向服务器的<code>serverfix</code> 分支的引用。:warning:【<strong>注意</strong>】：当抓取(fetch)到新的远程跟踪分支时，<strong>本地不会</strong>自动生成一份可编辑的副本<code>serverfix</code> 分支 ，只有一个<strong>不可以修改的</strong> <code>origin/serverfix</code> 指针。可以运行 <code>git merge origin/serverfix</code> – 合并到当前所在的分支。 <strong><code>git pull</code> 在大多数情况下</strong>它的含义是一个 <code>git fetch</code> 紧接着一个 <code>git merge</code> 命令。</p>
<p>如果想要在自己的 <code>serverfix</code> 分支上工作，可以将其建立在远程跟踪分支之上，Git会帮你设置好上游分支：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b serverfix origin/serverfix</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Git 提供了一个快捷命令，效果同上：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout --track origin/serverfix</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 也可不同名：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b sf origin/serverfix</span></span><br></pre></td></tr></table></figure>
<p>也可显式地设置/修改正在跟踪的上游分支：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -u origin/serverfix   <span class="comment"># or --set-upstream-to</span></span></span><br><span class="line">Branch serverfix set up to track remote branch serverfix from origin.</span><br></pre></td></tr></table></figure>
<p>查看设置的所有跟踪分支，可以使用 <code>git branch -vv</code> </p>
<p>删除一个远程分支。只是从服务器上移除这个指针。Git 服务器通常会保留数据一段时间直到垃圾回收运行</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin --delete serverfix</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin :serverfix <span class="comment"># 用于较早版本的 Git</span></span></span><br></pre></td></tr></table></figure>


<h2 id="3-6-Git-分支-变基"><a href="#3-6-Git-分支-变基" class="headerlink" title="3.6 Git 分支 - 变基"></a>3.6 Git 分支 - 变基</h2><p>使用 <code>rebase</code> 命令将提交到<strong>某一分支上的所有修改都移至另一分支上</strong>，就好像“重新播放”一样。<strong>变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。</strong></p>
<p>可以提取在 <code>C4</code> 中引入的补丁和修改，然后在 <code>C3</code> 的基础上应用一次。它的原理是首先找到这两个分支（即当前分支 <code>experiment</code>、变基操作的目标基底分支 <code>master</code>）的最近共同祖先 <code>C2</code>，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件，然后将当前分支指向目标基底 <code>C3</code>, 最后以此将之前另存为临时文件的修改依序应用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph RL</span><br><span class="line">C4(C4&lt;br&gt;&lt;s&gt;expriment&lt;&#x2F;s&gt;) --&gt; C2</span><br><span class="line">C4&#39;(&quot;C4’&quot;&lt;br&gt;expriment&lt;br&gt;&lt;i&gt;&lt;small&gt;rebased&lt;&#x2F;small&gt;&lt;&#x2F;i&gt;) --&gt; C3</span><br><span class="line">C3(C3&lt;br&gt;master) --&gt; C2</span><br><span class="line">C2 --&gt; C1</span><br><span class="line">style C4 opacity:0.7,stroke-width:4,stroke-dasharray:6,stroke:tan</span><br><span class="line">style C4&#39; stroke-width:4,stroke:orange</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout experiment   <span class="comment"># 当前分支是 experiment</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rebase master         <span class="comment"># 变基 experiment 到 master上</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="comment"># 现在，expriment 在 master 前面了。</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout master</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge experiment      <span class="comment"># 将 expriment 合并到 master 分支上 （快进合并）</span></span></span><br></pre></td></tr></table></figure>

<p> <code>git rebase [basebranch] [topicbranch]</code> ：直接将特性分支（ <code>server</code>）变基到目标分支（即 <code>master</code>）上。这样做能省去你先checkout到 <code>server</code> 分支，再对其执行变基命令的多个步骤。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git rebase master server  <span class="comment"># 变基 server 到 master 上</span></span></span><br></pre></td></tr></table></figure>
<p>使用 <code>git rebase --onto</code> ，如下：取出 <code>client</code> 分支，选中在 <code>client</code> 分支里但不在 <code>server</code> 分支里的修改（即 <code>C8</code> 和 <code>C9</code>），将它们在 <code>master</code> 分支上重放。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git rebase --onto master server client</span></span><br></pre></td></tr></table></figure>
<p>:speech_balloon: 总结一下，下面的命令（feature 变基到 master 上）是等价的。If &lt;upstream&gt; is not specified, the upstream configured in <code>branch.&lt;name&gt;.merge</code>  will be used (see <a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-config">git-config1</a> for details) and the <code>--fork-point</code> option is assumed.  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase --onto master master feature</span><br><span class="line">$ git rebase master feature</span><br><span class="line">$ git rebase master   # 假定目前的分支是 feature</span><br><span class="line">$ git rebase          # 若配置好了 branch.&lt;name&gt;.merge</span><br><span class="line"></span><br><span class="line"># Referance Format</span><br><span class="line">$ git rebase [-i | --interactive] [&lt;options&gt;] [--exec &lt;cmd&gt;] [--onto &lt;newbase&gt;]</span><br><span class="line">	[&lt;upstream&gt; [&lt;branch&gt;]]</span><br></pre></td></tr></table></figure>


<p><img src="/2018/12/12/Pro-Git-Tips/interesting-rebase-2.png" alt="截取特性分支上的另一个特性分支，然后变基到其他分支。"></p>
<h4 id="不合理的变基"><a href="#不合理的变基" class="headerlink" title="不合理的变基"></a>不合理的变基</h4><p><strong>不要对在你的仓库外有副本的分支执行变基。</strong> <strong>变基操作的实质</strong>是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。如果你用 <code>git rebase</code> 命令重新整理了提交并再次推送，你的同伴因此将不得不再次将他们手头的工作与你的提交进行整合，如果接下来你还要拉取并整合他们修改过的提交，事情就会变得一团糟。</p>
<p><strong>用变基解决变基。</strong>你拉取被覆盖过的更新并将你手头的工作基于此进行变基的话，一般情况下 Git 都能成功分辨出哪些是你的修改，并把它们应用到新分支上。</p>
<p>下面的例子（去看原文）中，我们不是执行合并，而是执行 <code>git rebase teamone/master</code></p>
<p><img src="https://git-scm.com/book/en/v2/images/perils-of-rebasing-4.png" alt="你将相同的内容又合并了一次，生成了一个新的提交。"></p>
<h2 id="4-1-服务器上的-Git-协议"><a href="#4-1-服务器上的-Git-协议" class="headerlink" title="4.1 服务器上的 Git - 协议"></a>4.1 服务器上的 Git - 协议</h2><p>一个远程仓库通常只是一个<strong>裸仓库</strong>（<em>bare repository</em>）— 即一个没有当前工作目录的仓库，存放的只有 Git 的资料。简单的说，裸仓库仅是你工程目录内的 <code>.git</code> 子目录内容。</p>
<p>Git 可以使用<strong>四种主要的协议</strong>来传输资料：本地协议（Local），HTTP 协议（Smart / Dumb），SSH（Secure Shell）协议及 Git 协议。</p>
<p>最基本的就是 <em>本地协议（Local protocol）</em> ，其中的远程版本库就是硬盘内的另一个目录。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> /opt/git/project.git</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 或你可以执行这个命令：</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> file:///opt/git/project.git</span></span><br></pre></td></tr></table></figure>
<p>如果在 URL 开头明确的指定 <code>file://</code>，那么 Git 的行为会略有不同。如果仅是指定路径，Git 会尝试使用硬链接（hard link）或直接复制所需要的文件。如果指定 <code>file://</code>，Git 会触发平时用于网路传输资料的进程，那通常是传输效率较低的方法。</p>
<p>Git 通过 HTTP 通信有两种模式。智能 HTTP 协议即支持像 <code>git://</code> 协议一样设置匿名服务，也可以像 SSH 协议一样提供传输时的授权和加密。哑 HTTP 协议里 web 服务器仅把裸版本库当作普通文件来对待，提供文件服务。哑 HTTP 协议的优美之处在于设置起来简单。如果你在 HTTP 上使用需授权的推送，管理凭证会比使用 SSH 密钥认证麻烦一些。参考 <a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/ch00/r_credential_caching">凭证存储</a> 如何安全地保存 HTTP 密码。</p>
<p>SSH 协议很高效，SSH 协议的缺点在于你不能通过他实现匿名访问。</p>
<p>Git 协议没有授权机制。目前，Git 协议是 Git 使用的网络传输协议里最快的。它缺乏授权机制，通常不能允许用户使用 Git 协议推送。</p>
<blockquote>
<p> HTTPS 如何指定证书？ ==&gt; “凭证存储”章节</p>
</blockquote>
<h2 id="4-2-服务器上的-Git-在服务器上搭建-Git"><a href="#4-2-服务器上的-Git-在服务器上搭建-Git" class="headerlink" title="4.2 服务器上的 Git - 在服务器上搭建 Git"></a>4.2 服务器上的 Git - 在服务器上搭建 Git</h2><p>在开始架设 Git 服务器前，需要把现有仓库导出为裸仓库。加上 <code>--bare</code>选项，只取出 Git 仓库自身，不要工作目录，然后特别为它单独创建一个目录。 <em>按照惯例，裸仓库目录名以 .git 结尾</em>。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> --bare my_project my_project.git</span></span><br></pre></td></tr></table></figure>





<h2 id="5-2-分布式-Git-向一个项目贡献"><a href="#5-2-分布式-Git-向一个项目贡献" class="headerlink" title="5.2 分布式 Git - 向一个项目贡献"></a>5.2 分布式 Git - 向一个项目贡献</h2><p>运行 <code>git diff --check</code>，它将会找到可能的空白错误并将它们为你列出来</p>
<h2 id="7-1-Git-工具-选择修订版本-star"><a href="#7-1-Git-工具-选择修订版本-star" class="headerlink" title="7.1 Git 工具 - 选择修订版本:star:"></a>7.1 Git 工具 - 选择修订版本:star:</h2><p>值得注意的是，<strong>引用日志只存在于本地仓库</strong>，它是一个记录你在你自己的仓库里做过什么的日志。 其他人拷贝的仓库里的引用日志不会和你的相同。而你新克隆一个仓库的时候，引用日志是空的，因为你在仓库里还没有操作。</p>
<p>好几种选择某一特定版本的方式：</p>
<ul>
<li><em>SHA-1</em>。当然你提供的 SHA-1 字符数量不得少于 4 个，并且没有歧义。</li>
<li>分支引用</li>
<li>引用日志 (<code>git reflog</code>)：<code>HEAD@&#123;5&#125;  master@&#123;yesterday&#125;</code></li>
<li>祖先引用。<code>^n</code> 与 <code>~n</code> 的区别：<ul>
<li> <code>HEAD^</code>     <code>HEAD^2  # 第二父提交</code></li>
<li><code>HEAD~2</code>  第一父提交的第一父提交 ，等价于 <code>HEAD^^</code></li>
</ul>
</li>
<li>提交区间 :star:<ul>
<li><code>master..experiment</code>   experiment 分支中未在 master 分支（哪些提交尚未被合并入 master 分支）</li>
<li><code>master...experiment</code>  master 或者 experiment 中包含的但不是两者共有的提交</li>
</ul>
</li>
</ul>
<p>因此下列3个命令是等价的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git log refA..refB   # 在 refA 但不在 refB 中</span><br><span class="line">$ git log ^refA refB</span><br><span class="line">$ git log refB --not refA   </span><br></pre></td></tr></table></figure>
<p>你想查看所有被 <code>refA</code> 或 <code>refB</code> 包含的但是不被 <code>refC</code> 包含的提交</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git log refA refB ^refC</span><br><span class="line">$ git log refA refB --not refC   </span><br></pre></td></tr></table></figure>
<p>另一个常用的场景是查看你即将推送到远端的内容：输出在你当前分支中而不在远程 <code>origin</code> 中的提交。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git log origin&#x2F;master..HEAD       </span><br></pre></td></tr></table></figure>


<h2 id="7-2-Git-工具-交互式暂存"><a href="#7-2-Git-工具-交互式暂存" class="headerlink" title="7.2 Git 工具 - 交互式暂存"></a>7.2 Git 工具 - 交互式暂存</h2><blockquote>
<p>:speech_balloon: 个人感觉还是比较好用的！</p>
</blockquote>
<p>运行 <code>git add</code> 时使用 <code>-i</code> 或者 <code>--interactive</code> 选项，Git 将会进入一个交互式终端模式</p>
<p>可以在命令行中使用 <code>git add -p</code> 或 <code>git add --patch</code>来启动同样的脚本。</p>
<p>更进一步地，可以使用 <code>reset --patch</code> 命令的补丁模式来部分重置文件，通过 <code>checkout --patch</code> 命令来部分检出文件与 <code>stash save --patch</code> 命令来部分暂存文件。</p>
<p>默认情况下，<code>git clean</code> 命令只会移除没有忽略的未跟踪文件。 任何与 <code>.gitiignore</code> 或其他忽略文件中的模式匹配的文件都不会被移除。 </p>
<p>现在运行 <code>git status</code> 会没有输出，因为三棵树又变得相同了。</p>
<p><code>reset</code> 做的第一件事是移动 HEAD 的指向。 这与改变 HEAD 自身不同（<code>checkout</code> 所做的）；<code>reset</code> 移动 HEAD 指向的分支。</p>
<h2 id="7-3-Git-工具-储藏与清理"><a href="#7-3-Git-工具-储藏与清理" class="headerlink" title="7.3 Git 工具 - 储藏与清理"></a>7.3 Git 工具 - 储藏与清理</h2><h4 id="1-gt-git-stash-list-save-apply-pop-drop"><a href="#1-gt-git-stash-list-save-apply-pop-drop" class="headerlink" title="1&gt; git stash list | save | apply | pop | drop"></a>1&gt; <strong><code>git stash list </code></strong><code>| save | apply | pop | drop</code></h4><p><code>git stash</code> = <code>git stash save</code> (修改的跟踪文件与暂存的改动)。将你刚刚储藏的工作重新应用：<code>git stash apply</code>。如果想要应用其中一个更旧的储藏，可以通过名字指定它，像这样：<code>git stash apply stash@&#123;2&#125;</code>。运行 <code>git stash drop</code> 加上将要移除的储藏的名字来移除它。运行 <code>git stash pop</code> 来应用储藏然后立即从栈上扔掉它。</p>
<p>使用 <code>git stash apply --index</code> 选项来尝试重新应用暂存的修改。 If the <code>--index</code> option is used, then tries to reinstate not only the working tree’s changes, <em>but also the index’s ones</em>. </p>
<p>一些实用的<code>save</code>选项：</p>
<ul>
<li><p><code>stash save</code>  <code>--keep-index</code> 选项。If the <code>--keep-index</code> option is used, all changes already added to the index are left intact. 它告诉 Git 不要储藏任何你通过 git add 命令已暂存的东西。</p>
</li>
<li><p>默认情况下，<code>git stash save</code> 只会储藏已经在仓库中的文件。如果指定 <code>--include-untracked</code> 或 <code>-u</code> 标记，Git 也会储藏任何创建的未跟踪文件。</p>
</li>
<li><p><code>-p</code> <code>--patch</code> 标记，交互式地提示</p>
</li>
<li><p><code>--all</code> 暂存被忽略的文件 <strong>和</strong> 未跟踪的文件。（见下文）</p>
</li>
<li><table>
<thead>
<tr>
<th>选项</th>
<th>Modified files</th>
<th>In Index</th>
<th>Untracked</th>
<th>Ignored</th>
</tr>
</thead>
<tbody><tr>
<td><code>save --keep-index</code></td>
<td>✓</td>
<td>✘</td>
<td>✗</td>
<td>✗</td>
</tr>
<tr>
<td><code>save</code>   <small>(default)</small></td>
<td>✓</td>
<td>✓</td>
<td>✗</td>
<td>✗</td>
</tr>
<tr>
<td><code>save --include-untracked</code></td>
<td>✓</td>
<td>✓</td>
<td>✔</td>
<td>✗</td>
</tr>
<tr>
<td><code>save --all</code></td>
<td>✓</td>
<td>✓</td>
<td>✔</td>
<td>✔</td>
</tr>
</tbody></table>
</li>
</ul>
<p>可以运行 <code>git stash branch &lt;branch_name&gt;</code> 创建一个新分支，检出<strong>储藏工作时所在的</strong>提交，重新在那应用工作，然后在应用<strong>成功后扔掉储藏</strong>。</p>
<h4 id="2-gt-git-clean"><a href="#2-gt-git-clean" class="headerlink" title="2&gt; git clean"></a>2&gt; <strong><code>git clean</code></strong></h4><p>谨慎，因为它会从工作目录中<strong>移除未被追踪的文件</strong> 。<em>默认情况</em>下，<code>git clean</code> 命令只会移除<strong>没有被忽略的未跟踪文件</strong>(untracked)。<code>clean -x</code> ，<strong>忽略列表中匹配的文件都会被移除</strong>。（也就是说，被设为忽略的未跟踪文件也会被移除。）</p>
<p>一个更安全的选项是运行 <code>git stash --all</code> 来移除每一样东西并存放在栈中。 If the <code>--all</code> option is used instead then the ignored files are stashed and cleaned in addition to the untracked files.</p>
<p>使用<code>git clean -f -d</code>命令来移除工作目录中所有未追踪的文件<strong>以及空的子目录</strong>。<code>-f</code> 意味着 <em>强制</em> 或 “确定移除”。</p>
<p>可以使用 <code>-n</code> 选项来运行命令做一次演习。</p>
<p>另一个小心处理过程的方式是使用 <code>-i</code> 或 <code>--interactive</code> 标记来交互式地运行它。</p>
<h2 id="7-4-Git-工具-签署工作"><a href="#7-4-Git-工具-签署工作" class="headerlink" title="7.4 Git 工具 - 签署工作"></a>7.4 Git 工具 - 签署工作</h2><p>一旦你有一个可以签署的私钥，可以通过设置 Git 的 <code>user.signingkey</code> 选项来签署。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.signingkey 0A46826A</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>签署标签</strong></p>
<ul>
<li><code>git tag -s v1.5 -m &#39;my signed 1.5 tag&#39;</code>：签署新的标签，使用  -s  代替  -a  即可。</li>
<li><code>git show v1.5</code> ：在那个标签上运行，会看到你的 GPG 签名附属在后面。</li>
<li><code>git tag -v [tag-name]</code>：验证一个签署的标签，使用 GPG 来验证签名<ul>
<li>（签署者的公钥需要在你的钥匙链中。）</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>签署提交</strong></p>
<ul>
<li> <code>git commit -S</code> ：签署个人提交。</li>
<li><code>git merge -S</code>：签署自己生成的合并提交。</li>
<li><code>git log --show-signature</code> ：查看及验证这些签名。</li>
<li><code>git merge</code> 与<code>git pull</code> 使用 <code>--verify-signatures</code> 选项来检查并拒绝没有携带可信 GPG 签名的提交。 </li>
</ul>
</li>
</ul>
<h2 id="7-5-Git-工具-搜索-star"><a href="#7-5-Git-工具-搜索-star" class="headerlink" title="7.5 Git 工具 - 搜索 :star:"></a>7.5 Git 工具 - 搜索 :star:</h2><p>**<code>git grep</code>  **</p>
<p>从提交历史或者工作目录中查找一个字符串或者正则表达式。</p>
<p>可以有丰富的参数：</p>
<ul>
<li><p> <code>-n</code> 输出 Git 所找到的匹配行行号。</p>
</li>
<li><p><code>--count</code> 选项来使 Git 输出概述的信息（每个文件包含了多少个匹配）</p>
</li>
<li><p><code>-p</code>属于哪一个方法或者函数</p>
</li>
<li><p><code>--heading</code>  <code>--break</code></p>
</li>
</ul>
<p><strong><code>git log -S</code> (日志搜索)</strong></p>
<p>例如，如果我们想找到 <code>ZLIB_BUF_MAX</code> 常量是什么时候引入的，我们可以使用 <code>-S</code> 选项来显示新增和删除该字符串的提交。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -S ZLIB_BUF_MAX --oneline</span></span><br><span class="line">e01503b zlib: allow feeding more than 4GB in one go</span><br><span class="line">ef49a7a zlib: zlib can only process 4GB at a time</span><br></pre></td></tr></table></figure>


<p><strong><code>git log -L</code>（行日志搜索）</strong></p>
<p>它可以展示代码中一行或者一个函数的历史。</p>
<h2 id="7-6-Git-工具-重写历史"><a href="#7-6-Git-工具-重写历史" class="headerlink" title="7.6 Git 工具 - 重写历史"></a>7.6 Git 工具 - 重写历史</h2><p>一、 <code>git commit --amend</code></p>
<p>二、可以通过给 <code>git rebase</code> 增加 <code>-i</code> 选项来交互式地运行变基。必须指定想要重写多久远的历史。它将最旧的而不是最新的列在上面。在 <code>HEAD~3..HEAD</code> 范围内的<strong>每一个提交都会被重写，无论你是否修改信息</strong> 。要确保列表中的提交还没有推送到共享仓库中。</p>
<p>使用交互式变基来重新排序或完全移除提交。【详见原文】</p>
<ol>
<li>修改多个提交信息</li>
<li>重新排序提交</li>
<li>压缩提交</li>
<li>拆分提交</li>
</ol>
<p>三、核武器级选项：<code>filter-branch</code>，它可以改写历史中大量的提交。查看ProGit原文来看一些<strong>骚操作</strong>。</p>
<h2 id="7-7-Git-工具-重置揭密-star"><a href="#7-7-Git-工具-重置揭密-star" class="headerlink" title="7.7 Git 工具 - 重置揭密 :star:"></a>7.7 Git 工具 - 重置揭密 :star:</h2><table>
<thead>
<tr>
<th>Git 里的三棵树树</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>HEAD</td>
<td>上一次提交的快照，下一次提交的父结点</td>
</tr>
<tr>
<td>Index</td>
<td>预期的下一次提交的快照</td>
</tr>
<tr>
<td>Working Directory</td>
<td>工作区（沙盒）</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph RL</span><br><span class="line">A((Work Dir)) &#x3D;&#x3D;stage&#x3D;&#x3D;&gt; B((Index))</span><br><span class="line">B &#x3D;&#x3D;Commit&#x3D;&#x3D;&gt; C((HEAD))</span><br><span class="line">C &#x3D;&#x3D;Checkout&#x3D;&#x3D;&gt; A</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>reset</code> 做的第一件事是移动 HEAD 的指向。这<strong>与改变 HEAD 自身不同</strong>，<code>reset</code> <strong>移动 HEAD 指向的分支</strong>。如果 HEAD 设置为 <code>master</code> 分支（正在 <code>master</code> 分支上），运行 <code>git reset 9e5e64a</code> 将会使 <code>master</code> 指向 <code>9e5e64a</code>。</p>
<p>对比<code>commit</code>：当你在运行 <code>git commit</code> 时，Git 会创建一个新的提交，并移动 HEAD 所指向的分支来使其指向该提交。</p>
<p>接下来，<code> reset</code> 会用 HEAD 指向的当前快照的内容来更新索引（不带参数的<code>reset</code>）。这依然会撤销一上次 <em>提交</em>，但还会 <em>取消暂存</em> 所有的东西。于是，我们回滚到了所有 <code>git add</code> 和 <code>git commit</code> 的命令执行之前。</p>
<p>进一步地， <code>reset --hard</code> 强制覆盖了工作目录中的文件。</p>
<table>
<thead>
<tr>
<th align="right">提交过程</th>
<th align="center">工作树</th>
<th align="center">暂存区</th>
<th align="center">HEAD</th>
<th>重置过程</th>
</tr>
</thead>
<tbody><tr>
<td align="right"></td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td></td>
</tr>
<tr>
<td align="right">修改文件 (new.file)</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td>git reset HEAD^ –hard</td>
</tr>
<tr>
<td align="right">↓</td>
<td align="center">✓ (new.file)</td>
<td align="center">-</td>
<td align="center">-</td>
<td>↑</td>
</tr>
<tr>
<td align="right">git add</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td>git reset HEAD^ –mixed</td>
</tr>
<tr>
<td align="right">↓</td>
<td align="center">✓ (new.file)</td>
<td align="center">✓ (new.file)</td>
<td align="center">-</td>
<td>↑</td>
</tr>
<tr>
<td align="right">git commit</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td>git reset HEAD^ –soft</td>
</tr>
<tr>
<td align="right"></td>
<td align="center">✓ (new.file)</td>
<td align="center">✓ (new.file)</td>
<td align="center">✓ (new.file)</td>
<td></td>
</tr>
<tr>
<td align="right"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td></td>
</tr>
</tbody></table>
<p><code>reset</code> 命令会以特定的顺序重写这三棵树，在你指定以下选项时停止：</p>
<ol>
<li>移动 HEAD 分支的指向 <em>（若指定了 –soft，则到此停止）</em></li>
<li>使索引看起来像 HEAD <em>（若未指定 –hard，则到此停止）</em></li>
<li>使工作目录看起来像索引</li>
</ol>
<p>若<u>指定了一个路径</u>，例如运行 <code>git reset file.txt</code>（就是<code>git reset HEAD file.txt</code>），本质上只是将<code>file.txt</code> 从 HEAD 复制到索引中。</p>
<blockquote>
<p><code>git reset [-q][] [--] &lt;paths&gt;… </code></p>
<p>This form resets the index entries for all <code>&lt;paths&gt;</code> to their state at <code>&lt;tree-ish&gt;</code>.  (It does not affect the working tree or the current branch.)This means that <code>git reset &lt;paths&gt;</code> is the opposite of <code>git add &lt;paths&gt;</code>.(:speech_balloon: 也就是重置暂存区)</p>
</blockquote>
<p>利用这种新的功能来做一些有趣的事情 - 压缩提交。运行 <code>git reset --soft HEAD~2</code> 然后只需再次运行 <code>git commit</code>提交即可。</p>
<h4 id="reset-vs-checkout"><a href="#reset-vs-checkout" class="headerlink" title="reset vs. checkout"></a><code>reset</code> vs. <code>checkout</code></h4><p>第一，不同于 <code>reset --hard</code>，<code>checkout</code> 对工作目录是安全的，它会通过检查来确保不会将已更改的文件弄丢。其实它还更聪明一些。它会在工作目录中先试着简单合并一下，这样所有_还未修改过的_文件都会被更新。而 <code>reset --hard</code> 则会不做检查就全面地替换所有东西。:speech_balloon:</p>
<blockquote>
<p>:speech_balloon: checkout 有 <code>-f</code>选项，但reset没有。</p>
</blockquote>
<p>第二个重要的区别是如何更新 HEAD。<code>reset</code> 会移动 HEAD 分支的指向，而 <code>checkout</code> 只会移动 HEAD 自身来指向另一个分支/引用。</p>
<p>:warning: 运行 <code>checkout</code> 的另一种方式就是<u>指定一个文件路径</u>，用该次提交中的那个文件来更新索引，但是它也会覆盖工作目录中对应的文件。</p>
<p><code>git merge</code></p>
<p>这次使用 <code>-Xignore-all-space</code> 或 <code>-Xignore-space-change</code> 选项。<br>第一个选项忽略任意 <strong>数量</strong> 的已有空白的修改，第二个选项忽略所有空白修改。</p>
<p>用鲜为人知的 <code>git merge-file</code> 命令来重新合并那个文件。</p>
<h2 id="7-8-Git-工具-高级合并"><a href="#7-8-Git-工具-高级合并" class="headerlink" title="7.8 Git 工具 - 高级合并"></a>7.8 Git 工具 - 高级合并</h2><p>在合并冲突后直接运行的  <code>git diff</code> 会给你一个相当独特的输出格式——<strong>组合式差异格式</strong>。每一行给你两列加减号：第一列为你显示 “ours” 分支与工作目录的文件区别（添加或删除），第二列显示 “theirs” 分支与工作目录的拷贝区别。</p>
<p>要比较合并结果与在<em>你</em>的分支上的内容（看看合并引入了什么），可以运行 <code>git diff --ours</code>。要查看合并的结果与<em>他们</em>那边有什么不同，可以运行 <code>git diff --theirs</code>。</p>
<p>想要重置标记并尝试再次解决它们？ <code>git checkout --conflict</code>会重新检出文件并替换合并冲突标记。 <code>--conflict</code> 参数 <code>diff3</code> （在中间夹有 “base” 版本）或 <code>merge</code>（默认）。通过设置 <code>merge.conflictstyle</code> 选项为 <code>diff3</code> 来做为以后合并冲突的默认选项。</p>
<blockquote>
<p><code>git checkout--conflict=&lt;style&gt; </code></p>
<p>The same as –merge option above, but changes the way the conflicting hunks are presented, overriding the merge.conflictStyle configuration variable.  Possible values are “merge” (default) and “diff3” (in addition to what is shown by “merge” style, shows the original contents).</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout --conflict&#x3D;diff3 hello.rb  # For example.</span><br></pre></td></tr></table></figure>
<p><code>git checkout</code> 也可以用 <code>--ours</code> 和 <code>--theirs</code> 选项，你可以选择留下一边的修改而丢弃掉另一边修改。当有二进制文件冲突时这可能会特别有用。</p>
</blockquote>
<p>希望 Git 简单地选择特定的一边并忽略另外一边而不是让你手动合并冲突，你可以传递给 <code>merge</code> 命令一个 <code>-Xours</code> 或 <code>-Xtheirs</code> 参数。<code>git merge-file --ours</code> 的命令来合并单个文件。 例如下面的代码会做一次“假的”合并。它只会简单地把当前分支的代码当作合并结果记录下来。合并前后我们的分支并没有任何区别：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge -s ours mundo</span><br></pre></td></tr></table></figure>


<h4 id="star-撤消合并"><a href="#star-撤消合并" class="headerlink" title=":star:撤消合并"></a>:star:<a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%AB%98%E7%BA%A7%E5%90%88%E5%B9%B6">撤消合并</a></h4><blockquote>
<p>请移步到原文</p>
</blockquote>
<h4 id="子树合并"><a href="#子树合并" class="headerlink" title="子树合并"></a>子树合并</h4><p>子树合并的思想是你有两个项目，并且其中一个映射到另一个项目的一个子目录。Git 通常可以自动计算出其中一个是另外一个的子树从而实现正确的合并。（ 需要深入讨论​  ）。 </p>
<blockquote>
<p>:speech_balloon: GitHub 上的参考：<a target="_blank" rel="noopener" href="https://help.github.com/articles/about-git-subtree-merges/">https://help.github.com/articles/about-git-subtree-merges/</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.atlassian.com/blog/2015/05/the-power-of-git-subtree/">https://developer.atlassian.com/blog/2015/05/the-power-of-git-subtree/</a></p>
<p><code>--allow-unrelated-histories</code> 很关键</p>
<p><em>Pro Git</em> 上的搞不清楚</p>
<p><code>--squash</code> 会丢掉 commit 信息</p>
<p>不知为什么，Git 官方参考没有 git-subtree 条目！！！</p>
</blockquote>
<h2 id="7-9-Git-工具-Rerere"><a href="#7-9-Git-工具-Rerere" class="headerlink" title="7.9 Git 工具 - Rerere"></a>7.9 Git 工具 - Rerere</h2><p> Git 记住解决一个块冲突的方法，这样在下一次看到相同冲突时可以自动地解决。</p>
<p><strong>启用 <code>rerere</code> 功能：</strong></p>
<ol>
<li><code>$ git config --global rerere.enabled true</code></li>
<li>或者在特定的仓库中创建 <code>.git/rr-cache</code> 目录来开启<em>（推荐第一种）</em></li>
</ol>
<p><strong>How To Do ?</strong></p>
<ol>
<li><p>下一次遇到合并冲突时，会有这一行：<br> <code>Recorded preimage for &#39;hello.rb&#39;</code></p>
</li>
<li><p> 运行<code>git rerere status</code> 会告诉你它记录的合并前状态。</p>
</li>
<li><p>并且 <code>git rerere diff</code> 将会显示解决方案的当前状态。</p>
</li>
<li><p>手动修改文件后，再次运行 <code>rerere diff</code> 命令来查看 rerere 将会记住的内容</p>
</li>
<li><p>将冲突文件标记为已解决(<code>git add</code>)并提交。Git 提示：<code>Recorded resolution for FILE</code></p>
</li>
<li><p>再次遇到冲突，Git 提示 <code>Resolved FILE using previous resolution</code>——那个冲突已经被解决了，也没有冲突标记。<code>git diff</code> 将会显示出它是如何自动地重新解决的。</p>
</li>
</ol>
<p>也可以通过 <code>checkout</code> 命令重新恢复到冲突时候的文件状态：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout --conflict=merge hello.rb</span></span><br></pre></td></tr></table></figure>
<p>现在可以通过运行 <code>rerere</code> 来重新解决它：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git rerere</span></span><br></pre></td></tr></table></figure>


<h2 id="7-10-Git-工具-使用-Git-调试"><a href="#7-10-Git-工具-使用-Git-调试" class="headerlink" title="7.10 Git 工具 - 使用 Git 调试"></a>7.10 Git 工具 - 使用 Git 调试</h2><h4 id="文件标注"><a href="#文件标注" class="headerlink" title="文件标注"></a>文件标注</h4><p>在代码中看到一个有问题的方法，使用 <code>git blame &lt;file&gt;</code> 标注，查看这个方法每一行的最后修改时间以及是被谁修改的。 这个例子使用 <code>-L</code> 选项来限制输出范围在第12至22行。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git blame -L 12,22 simplegit.rb</span></span><br><span class="line">^4832fe2 (Scott Chacon  2008-03-15 10:31:28 -0700 12)  def show(tree = &#x27;master&#x27;)</span><br><span class="line"><span class="meta">#</span><span class="bash">  SHA-1  作者名字       时间                      行号 文件内容</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   ┖── `^` 代表在这一次提交，文件第一次加入到这个项目。</span></span><br><span class="line">9f6560e4 (Scott Chacon  2008-03-17 21:52:20 -0700 16)  def log(tree = &#x27;master&#x27;)</span><br></pre></td></tr></table></figure>
<p>在 <code>git blame</code> 后面加上一个 <code>-C</code>，尝试找出文件中从别的地方复制过来的代码片段的原始出处。</p>
<h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p><code>bisect</code> 命令会对你的提交历史进行二分查找来帮助你尽快找到是哪一个提交引入了问题。</p>
<ol>
<li>首先执行 <code>git bisect start</code> 来启动</li>
<li>接着执行 <code>git bisect bad</code> 来告诉系统当前你所在的提交是有问题的。然后使用 <code>git bisect good [good_commit]</code>最后一次正常状态是哪次提交</li>
<li> Git 检出中间的那个提交。你执行测试，并使用<code>git bisect good | bad</code> 来指出这一提交是否正常。</li>
<li>重复上面的步骤，Git 会告诉你第一个错误提交是哪个。</li>
<li><code>git bisect reset</code>，重置你的 HEAD 指针到最开始的位置。</li>
</ol>
<p>也可以通过 <code>bisect start</code> 命令的参数来设定好二分查找范围：第一个参数是不正常的提交，第二个是正常的提交。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git bisect start HEAD v1.0</span><br></pre></td></tr></table></figure>
<p>配合脚本也可实现自动化的二分查找。</p>
<h2 id="7-11-Git-工具-子模块"><a href="#7-11-Git-工具-子模块" class="headerlink" title="7.11 Git 工具 - 子模块"></a>7.11 Git 工具 - 子模块</h2><blockquote>
<p>参见原文来查看具体如何操作。</p>
</blockquote>
<p>当你提交时，会看到类似下面的信息：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -am <span class="string">&#x27;added DbConnector module&#x27;</span></span></span><br><span class="line">[master fb9093c] added DbConnector module</span><br><span class="line"> 2 files changed, 4 insertions(+)</span><br><span class="line"> create mode 100644 .gitmodules</span><br><span class="line"> create mode 160000 DbConnector</span><br></pre></td></tr></table></figure>
<p>注意 DbConnector 记录的 <code>160000</code> 模式。 这是 Git 中的一种特殊模式，它本质上意味着你是将一次提交记作一项目录记录的，而非将它记录成一个子目录或者一个文件。</p>
<h2 id="7-12-Git-工具-打包"><a href="#7-12-Git-工具-打包" class="headerlink" title="7.12 Git 工具 - 打包"></a>7.12 Git 工具 - 打包</h2><p><code>git bundle</code> 命令会将 <code>git push</code> 命令所传输的所有内容打包成一个二进制文件，你可以传给其他人，然后解包到其他的仓库中。当你在没有合适的网络或者可共享仓库的情况下，<code>git bundle</code> 很适合用于共享或者网络类型的操作。</p>
<p><code>git bundle verify</code> 命令可以检查这个文件是否是一个合法的 Git 包，是否拥有共同的祖先来导入。</p>
<p>可以使用 <code>fetch</code> 或者 <code>pull</code> 命令从包中导入提交。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> repo.bundle repo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git bundle create repo.bundle HEAD master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果你希望这个仓库可以在别处被克隆，你应该像例子中那样增加一个 HEAD 引用。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git bundle verify ../commits.bundle        <span class="comment"># 检查这个文件是否合法</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git bundle list-heads ../commits.bundle    <span class="comment"># 查看这边包里可以导入哪些分支</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git fetch ../commits.bundle master:other-master  <span class="comment"># 可用fetch或pull命令</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
</blockquote>
<h2 id="7-13-Git-工具-替换"><a href="#7-13-Git-工具-替换" class="headerlink" title="7.13 Git 工具 - 替换"></a>7.13 Git 工具 - 替换</h2><blockquote>
<p>:warning:阅读原文来获得具体的示例。</p>
</blockquote>
<p><code>replace</code> 命令可以让你在 Git 中指定一个对象并可以声称“每次你遇到这个 Git 对象时，假装它是其他的东西”。<br>在你用一个不同的提交替换历史中的一个提交时，这会非常有用。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git replace 81a708d c6e1e95</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>:warning: 类似于取一个别名或者“重定向”。提交本身没有变化。</p>
</blockquote>
<p>我们可以将替换推送到服务器中并且其他人可以轻松地下载。*(替换是存储在)Git仓库里面的！*</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git for-each-ref</span><br><span class="line">55b47 commit refs&#x2F;heads&#x2F;master</span><br><span class="line">55b47 commit refs&#x2F;heads&#x2F;other-master</span><br><span class="line">bfa81 commit refs&#x2F;replace&#x2F;ecee6</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>-d</code>   or  <code>--delete</code>  – Delete existing replace refs for the given objects</p>
</blockquote>
<h2 id="7-14-Git-工具-凭证存储"><a href="#7-14-Git-工具-凭证存储" class="headerlink" title="7.14 Git 工具 - 凭证存储"></a>7.14 Git 工具 - 凭证存储</h2><h4 id="Git-凭证存储"><a href="#Git-凭证存储" class="headerlink" title="Git 凭证存储"></a>Git 凭证存储</h4><p>HTTP 协议每一个连接都是需要用户名和密码的。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --global credential.helper cache</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th></th>
<th><code>git config --global credential.helper xxx</code></th>
</tr>
</thead>
<tbody><tr>
<td>default</td>
<td>所有都不缓存。每一次连接都会询问你的用户名和密码。</td>
</tr>
<tr>
<td>cache</td>
<td>放在内存中一段时间。永远不会被存储在磁盘中</td>
</tr>
<tr>
<td>store</td>
<td>用明文的形式存放在磁盘中，并且永不过期。</td>
</tr>
<tr>
<td>osxkeychain</td>
<td>存到 MacOS 用户的钥匙串中。</td>
</tr>
<tr>
<td>winstore</td>
<td>使用 Windows Credential Store 来控制敏感信息。（需“winstore” 辅助工具）</td>
</tr>
</tbody></table>
<p>Git 甚至允许<strong>你配置多个辅助工具</strong>。 当查找特定服务器的凭证时，Git 会按顺序查询，并且<strong>在找到第一个回答时停止查询</strong>。 当保存凭证时，Git 会将用户名和密码发送给 <strong>所有</strong> 配置列表中的辅助工具，它们会按自己的方式处理用户名和密码。 如果你在闪存上有一个凭证文件，但又希望在该闪存被拔出的情况下使用内存缓存来保存用户名密码，<code>.gitconfig</code> 配置文件如下：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[credential]</span></span><br><span class="line">    <span class="attr">helper</span> = store --file /mnt/thumbdrive/.git-credentials</span><br><span class="line">    <span class="attr">helper</span> = cache --timeout <span class="number">30000</span></span><br></pre></td></tr></table></figure>
<ul>
<li>也可自己写一个认证程序 </li>
<li>正如你看到的，扩展这个系统是相当简单的！</li>
</ul>
<h2 id="7-15-Git-工具-总结"><a href="#7-15-Git-工具-总结" class="headerlink" title="7.15 Git 工具 - 总结"></a>7.15 Git 工具 - 总结</h2><p>当你碰到问题时，你应该可以很容易找出是哪个分支在什么时候由谁引入了它们。 如果你想在项目中使用子项目，你也已经知道如何来满足这些需求。 到此，<strong>你应该能毫无压力地在命令行中使用 Git 来完成日常中的大部分事情</strong>。</p>
<h2 id="8-1-自定义-Git-配置-Git"><a href="#8-1-自定义-Git-配置-Git" class="headerlink" title="8.1 自定义 Git - 配置 Git"></a>8.1 自定义 Git - 配置 Git</h2><ul>
<li><p>设置编辑器:heart:<br><code>git config --global core.editor emacs</code></p>
</li>
<li><p>设置提交默认内容（提交模板）:heart:<br>  <code>$ git config --global commit.template ~/.gitmessage.txt</code></p>
</li>
<li><p>全局排除 :heart:<br> <code>git config --global core.excludesfile ~/.gitignore_global</code></p>
<blockquote>
<p><code>core.excludesFile</code></p>
<p> Specifies the pathname to the file that contains patterns to describe paths that are not meant to be tracked, *in addition to .gitignore (per-directory) and <code>.git/info/exclude</code>. Defaults to <code>$XDG_CONFIG_HOME/git/ignore</code>. If  <code>$XDG_CONFIG_HOME</code> is either not set or empty, <code>$HOME/.config/git/ignore</code> is used instead. See gitignore[5].</p>
</blockquote>
</li>
<li><p>:heart:如果你把 <code>help.autocorrect</code> 设置成 1，那么只要有一个命令被模糊匹配到了，Git 会自动运行该命令。</p>
</li>
</ul>
<h5 id="外部的合并与比较工具"><a href="#外部的合并与比较工具" class="headerlink" title="外部的合并与比较工具"></a>外部的合并与比较工具</h5><ul>
<li><p><code>git mergetool --tool=&lt;tool&gt;&lt;/tool&gt;</code></p>
<blockquote>
<p>-t <tool></tool></p>
<p>–tool=<tool></tool></p>
<p>Use the merge resolution program specified by <tool></tool>. <u>Valid values include emerge, gvimdiff, kdiff3, meld, vimdiff, and tortoisemerge. Run <code>git mergetool --tool-help</code> for the list of valid <tool></tool> settings.</u></p>
<p><u>If a merge resolution program is not specified, <em>git mergetool</em> will use the configuration variable<code>merge.tool</code></u>. If the configuration variable <code>merge.tool</code> is not set, <em>git mergetool</em> will pick a suitable default.</p>
</blockquote>
</li>
<li><p><code>diff.external</code></p>
<blockquote>
<p>If this config variable is set, diff generation is not performed using the internal diff machinery, but using the given command. Can be overridden with the ‘GIT_EXTERNAL_DIFF’ environment variable.</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>:warning:注意：也有 <code>git difftool</code> </p>
</blockquote>
<h2 id="8-2-自定义-Git-Git-属性"><a href="#8-2-自定义-Git-Git-属性" class="headerlink" title="8.2 自定义 Git - Git 属性"></a>8.2 自定义 Git - Git 属性</h2><p>针对特定的路径配置某些设置项，这样 Git 就只对特定的子目录或子文件集运用它们。这些<strong>基于路径的设置项被称为 Git 属性</strong>，可以在你的目录下的 <strong><code>.gitattributes</code> 文件</strong>内进行设置（通常是你的项目的根目录），也可以在  <code>.git/info/attributes</code> 文件。</p>
<p>将文件<strong>标记为二进制</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*.pbxproj binary</span><br></pre></td></tr></table></figure>
<p>如何<strong>比较二进制文件</strong>——很有意思。<em>（查看原文来看看）</em></p>
<p>在 <code>.gitattributes</code> 文件中，你能对特定的路径设置一个过滤器，然后设置文件检出前的处理脚本（“smudge”）和文件暂存前的处理脚本（“clean”）</p>
<p>运行 <code>git archive</code> 来创建项目的压缩包。</p>
<ul>
<li><p>标记二进制 <code>file.name  binary</code></p>
</li>
<li><p>自定义diif  <code>file.name diff=filter</code><br><code>$ git config diff.word.textconv docx2txt</code></p>
</li>
<li><p><code>*.c filter=indent</code><br>编写自己的过滤器来实现文件提交或检出时的关键字替换。<br>文件所对应数据对象的 SHA-1 校验和自动注入到文件中的 <code>$Id$</code> 字段</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --global filter.indent.clean indent</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global filter.indent.smudge cat</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>file.name  export-ignore</code></p>
</li>
</ul>
<blockquote>
<p>:question: 你无法利用它往文件中加入其关联提交的相关信息，因为 Git 总是先对文件做校验和运算</p>
<p>:question: （译者注：Git 中提交对象的校验依赖于文件的校验和，而 Git 属性针对特定文件或路径，因此基于 Git 属性的关键字展开无法仅根据文件反推出对应的提交）。</p>
</blockquote>
<ul>
<li><p>合并策略   <code>file.name merge=merge_strategy / ours</code></p>
<p>通过 Git 属性，你还能对项目中的<strong>特定文件指定不同的合并策略</strong>。例如，告诉 Git 当特定文件发生冲突时不要尝试合并它们，而是直接使用你这边的内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Ⅰ 设置 .gitattributes 如下：</span><br><span class="line">database.xml merge&#x3D;ours</span><br><span class="line"></span><br><span class="line"># Ⅱ 然后定义一个虚拟的合并策略，叫做 ours：</span><br><span class="line">git config --global  merge.ours.driver true</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="8-3-自定义-Git-Git-钩子"><a href="#8-3-自定义-Git-Git-钩子" class="headerlink" title="8.3 自定义 Git - Git 钩子"></a>8.3 自定义 Git - Git 钩子</h2><p>有两组这样的钩子：客户端的和服务器端的。<br>客户端钩子由诸如提交和合并这样的操作所调用，而服务器端钩子作用于诸如接收被推送的提交这样的联网操作。</p>
<p>钩子存储在： <code>.git/hooks</code>。放入 Git 目录下的 <code>hooks</code> 子目录中，即可激活该钩子脚本。</p>
<p>克隆某个版本库时，它的客户端钩子 <strong>并不</strong> 随同复制。</p>
<p>:speech_balloon: pre vs. post: post means done.</p>
<h4 id="客户端钩子"><a href="#客户端钩子" class="headerlink" title="客户端钩子"></a>客户端钩子</h4><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>pre-commit</code></td>
<td>跳过：<code>git commit --no-verify</code>…在键入提交信息前运行。例：Eslint</td>
</tr>
<tr>
<td><code>prepare-commit-msg</code></td>
<td>在启动编辑器前，默认信息被创建后运行。编辑提交者所看到的默认信息。对那些<strong>会自动产生默认信息的提交</strong>，如提交信息模板、合并提交、压缩提交和修订提交等非常实用。接收一些选项：存有当前提交信息的文件的路径、提交类型和修补提交的提交的 SHA-1 校验[^1]。</td>
</tr>
<tr>
<td><code>commit-msg</code></td>
<td>接收一个参数：存有当前提交信息的临时文件的路径。</td>
</tr>
<tr>
<td><code>post-commit</code></td>
<td>不接收任何参数。一般用于通知之类的事情。</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><code>pre-rebase</code></td>
<td></td>
</tr>
<tr>
<td><code>post-rewrite</code></td>
<td>被那些会替换提交记录的命令调用，比如 <code>git commit --amend</code> 和 <code>git rebase</code></td>
</tr>
<tr>
<td><code>post-checkout</code></td>
<td></td>
</tr>
<tr>
<td><code>post-merge</code></td>
<td></td>
</tr>
<tr>
<td><code>pre-push</code></td>
<td>更新了远程引用但尚未传送对象时被调用。</td>
</tr>
<tr>
<td><code>pre-auto-gc</code></td>
<td>会在垃圾回收开始之前被调用。偶尔调用 <code>git gc --auto</code> 进行垃圾回收。</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><code>pre-receive</code></td>
<td></td>
</tr>
<tr>
<td><code>update</code></td>
<td></td>
</tr>
<tr>
<td><code>post-receive</code></td>
<td></td>
</tr>
</tbody></table>
<p>[^1]: the commit SHA-1 if this is an amended commit.</p>
<h2 id="8-4-自定义-Git-使用强制策略的一个例子"><a href="#8-4-自定义-Git-使用强制策略的一个例子" class="headerlink" title="8.4 自定义 Git - 使用强制策略的一个例子"></a>8.4 自定义 Git - 使用强制策略的一个例子</h2><p>使用 <code>git log</code> 的 <code>--name-only</code> 选项</p>
<p>由于客户端钩子本身不跟随克隆的项目副本分发，所以你必须通过其他途径把这些钩子分发到用户的 <code>.git/hooks</code> 目录并设为可执行文件。</p>
<h2 id="10-1-Git-内部原理-底层命令和高层命令"><a href="#10-1-Git-内部原理-底层命令和高层命令" class="headerlink" title="10.1 Git 内部原理 - 底层命令和高层命令"></a>10.1 Git 内部原理 - 底层命令和高层命令</h2><p>Git 会创建一个 <code>.git</code> 目录。这个目录包含了几乎所有 Git 存储和操作的对象。如若想备份或复制一个版本库，只需把这个目录拷贝至另一处即可。</p>
<p><code>config</code> 文件包含项目特有的配置选项。 <code>info</code> 目录包含一个全局性排除（global exclude）文件，用以放置那些不希望被记录在 <code>.gitignore</code> 文件中的忽略模式（ignored patterns）。 <code>hooks</code> 目录包含客户端或服务端的钩子脚本（hook scripts）。</p>
<p>剩下的四个条目很重要：<code>HEAD</code> 文件、（尚待创建的）<code>index</code> 文件，和 <code>objects</code> 目录、<code>refs</code> 目录。 这些条目是 Git 的核心组成部分。 <u><code>objects</code> 目录存储所有数据内容；<code>refs</code> 目录存储指向数据（分支）的提交对象的指针；<code>HEAD</code> 文件指示目前被检出的分支；<code>index</code> 文件保存暂存区信息。 我们将详细地逐一检视这四部分，以期理解 Git 是如何运转的。</u></p>
<h2 id="10-2-Git-内部原理-Git-对象"><a href="#10-2-Git-内部原理-Git-对象" class="headerlink" title="10.2 Git 内部原理 - Git 对象"></a>10.2 Git 内部原理 - Git 对象</h2><ul>
<li><p><input disabled="" type="checkbox">  [TODO] 试着还原一下object文件夹里面的内容。<strong>TODO</strong></p>
</li>
<li><p>Git 会通过 zlib 压缩这条新内容。</p>
</li>
</ul>
<h2 id="10-3-Git-内部原理-Git-引用-star"><a href="#10-3-Git-内部原理-Git-引用-star" class="headerlink" title="10.3 Git 内部原理 - Git 引用:star:"></a>10.3 Git 内部原理 - Git 引用:star:</h2><p>用一个名字指针来替代原始的 SHA-1 值，这样的文件被称为“引用（references，缩写为 refs）”；在 <code>.git/refs</code> 目录下。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;1a410efbd13591db07496601ebc7a059dd55cfe9&quot; &gt; .git/refs/heads/master</span><br></pre></td></tr></table></figure>
<p>如果想更新某个引用，Git 提供了一个更加安全的命令 <code>update-ref</code> 来完成此事：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git update-ref refs/heads/master 1a410efbd13591db07496601ebc7a059dd55cfe9</span></span><br></pre></td></tr></table></figure>
<p><code>HEAD</code> 文件是一个<strong>符号引用（symbolic reference）</strong>，指向目前所在的分支。所谓符号引用，意味着它是一个<strong>指向其他引用的指针</strong>。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat .git/HEAD</span></span><br><span class="line">ref: refs/heads/test</span><br></pre></td></tr></table></figure>
<p>可以手动编辑该文件，然而同样存在一个更安全的命令来完成此事：<code>symbolic-ref</code>。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git symbolic-ref HEAD <span class="comment"># 查看值</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git symbolic-ref HEAD refs/heads/<span class="built_in">test</span>  <span class="comment"># 指定值</span></span></span><br></pre></td></tr></table></figure>
<p><strong>远程引用</strong></p>
<p>远程引用和分支（位于 <code>refs/heads</code> 目录下的引用）之间最主要的区别在于，<em>远程引用是只读的</em>。虽然可以 <code>git checkout</code> 到某个远程引用，但是 Git 并<em>不会将 HEAD 引用指向该远程引用</em>。因此，你永远不能通过 <code>commit</code> 命令来更新远程引用。</p>
<p><strong>标签引用</strong></p>
<p>轻量标签（<code>git tag</code>）：创建直接指向提交对象的引用，就是<code>git update-ref refs/tags/v1.0 cac0c</code>。</p>
<p>附注标签（<code>git tag -a</code>）：会<em>创建一个标签对象</em>，并记录一个引用来指向该标签对象。</p>
<h2 id="10-4-Git-内部原理-包文件"><a href="#10-4-Git-内部原理-包文件" class="headerlink" title="10.4 Git 内部原理 - 包文件"></a>10.4 Git 内部原理 - 包文件</h2><p>Git 最初向磁盘中存储对象时所使用的格式被称为“松散（loose）”对象格式。将多个这些对象打包成一个称为“包文件（packfile）”的二进制文件，以节省空间和提高效率。</p>
<p>新创建的包文件和一个索引。包文件包含了刚才从文件系统中移除的所有对象的内容。索引文件包含了包文件的偏移信息</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.git/objects/pack/pack-978e03944f5c581011e6998cd0e9e30000905586.idx</span><br><span class="line">.git/objects/pack/pack-978e03944f5c581011e6998cd0e9e30000905586.pack</span><br></pre></td></tr></table></figure>
<p>【When?】当版本库中有太多的松散对象，或者你手动执行 <code>git gc</code> 命令，或者你向远程服务器执行推送时。</p>
<p>没将它们添加至任何提交记录中，是悬空（dangling）的，不会将它们打包进新生成的包文件中。</p>
<p>同样有趣的地方在于，第二个版本完整保存了文件内容，而原始的版本反而是以差异方式保存的。</p>
<p>Git 时常会自动对仓库进行重新打包以节省空间。</p>
<h2 id="10-5-Git-内部原理-引用规格-star"><a href="#10-5-Git-内部原理-引用规格-star" class="headerlink" title="10.5 Git 内部原理 - 引用规格:star:"></a>10.5 Git 内部原理 - 引用规格:star:</h2><p>远程分支到本地引用的映射方式可以更复杂。</p>
<p><code>git add origin &lt;URL&gt;</code>会在<code>.git/config</code> 文件中添加一个小节，其中指定远程版本库的名称URL 和一个用于获取操作的<strong>引用规格（refspec）</strong>。引用规格的格式由一个可选的 <code>+</code> 号和紧随其后的 <code>&lt;src&gt;:&lt;dst&gt;</code> 组成：</p>
<ul>
<li><code>&lt;src&gt;</code> 是一个模式，代表<em>远程版本库</em>中的引用。</li>
<li><code>&lt;dst&gt;</code> 是那些远程引用<em>在本地所对应的位置</em>。</li>
<li><code>+</code> 号告诉 Git 即使在不能快进的情况下也要（强制）更新引用。</li>
</ul>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">	url = https://github.com/schacon/simplegit-progit</span><br><span class="line">	fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line">	</span><br><span class="line"><span class="meta">	#</span><span class="bash"> 想让 Git 每次只拉取(fetch)远程的 `master` 分支，而不是所有分支</span></span><br><span class="line">	fetch = +refs/heads/master:refs/remotes/origin/master</span><br><span class="line">	</span><br><span class="line"><span class="meta">	#</span><span class="bash"> 在配置文件中指定多个用于获取操作的引用规格</span></span><br><span class="line"><span class="meta">	#</span><span class="bash"> 下面的例子：每次获取时都包括 master 和 experiment 分支</span></span><br><span class="line">	fetch = +refs/heads/master:refs/remotes/origin/master</span><br><span class="line">	fetch = +refs/heads/experiment:refs/remotes/origin/experiment</span><br><span class="line"><span class="meta">	#</span><span class="bash"> 不能在模式中使用部分通配符，但可以：</span></span><br><span class="line">	fetch = +refs/heads/qa/*:refs/remotes/origin/qa/*</span><br></pre></td></tr></table></figure>
<p>Git 获取服务器中 <code>refs/heads/</code> 下面的所有引用，并将它写入到本地的<code>refs/remotes/origin/</code> 中。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> origin/master    <span class="comment"># 这些都可以访问到远端的 master 分支</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> remotes/origin/master</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> refs/remotes/origin/master</span></span><br></pre></td></tr></table></figure>
<p>上面的三个命令作用相同，因为 Git 会把它们都扩展成 <code>refs/remotes/origin/master</code>。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[remote &quot;origin&quot;]</span></span><br><span class="line">	<span class="attr">url</span> = https://github.com/schacon/simplegit-progit</span><br><span class="line">	<span class="attr">fetch</span> = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line">	<span class="attr">fetch</span> = +refs/heads/qa/*:refs/remotes/origin/qa/*</span><br></pre></td></tr></table></figure>


<p>如果有某些只希望被执行一次的操作，我们也可以在命令行指定引用规格：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 将远程的 master 分支拉到本地的 origin/mymaster 分支</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git fetch origin master:refs/remotes/origin/mymaster</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 你也可以指定多个引用规格。</span></span></span><br><span class="line">git fetch origin master:refs/remotes/origin/mymaster \</span><br><span class="line">	 topic:refs/remotes/origin/topic</span><br><span class="line">	 </span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 推送 `master` 分支到远程服务器的 `qa/master` 分支上</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin master:refs/heads/qa/master</span></span><br></pre></td></tr></table></figure>
<p>希望 Git 每次运行 <code>git push origin</code> 时都像上面这样推送，可以在配置文件中添加一条 <code>push</code> 值：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[remote &quot;origin&quot;]</span></span><br><span class="line">	<span class="attr">url</span> = https://github.com/schacon/simplegit-progit</span><br><span class="line">	<span class="attr">fetch</span> = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line">	<span class="attr">push</span> = refs/heads/master:refs/heads/qa/master</span><br><span class="line">	<span class="comment">## 默认把本地 master 分支推送到远程 qa/master 分支。</span></span><br></pre></td></tr></table></figure>


<p>从远程服务器上删除引用：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin :topic</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin --delete topic   <span class="comment"># 自Git v1.7.0以后可用</span></span></span><br></pre></td></tr></table></figure>


<h2 id="10-7-Git-内部原理-维护与数据恢复"><a href="#10-7-Git-内部原理-维护与数据恢复" class="headerlink" title="10.7 Git 内部原理 - 维护与数据恢复"></a>10.7 Git 内部原理 - 维护与数据恢复</h2><p>如果有太多松散对象（不在包文件中的对象）或者太多包文件，Git 会运行一个完整的 <code>git gc</code> 命令。“gc” 代表垃圾回收，这个命令会做以下事情：收集所有松散对象并将它们放置到包文件中，将多个包文件合并为一个大的包文件，移除与任何提交都不相关的陈旧对象。也可以手动执行自动垃圾回收：<code>git gc --auto</code></p>
<p>另一件事是打包你的引用(<code>.git/refs</code> 目录)到一个单独的文件(<code>.git/packed-refs</code>)。<code>refs</code> 目录中将不会再有这些文件。为了保证效率 Git 会将它们移动到名为 <code>.git/packed-refs</code> 的文件中。Git 会首先在 <code>refs</code> 目录中查找指定的引用，然后再到 <code>packed-refs</code> 文件中查找。  <code>packed-refs</code> 文件中的<code>^</code> 符号表示它上一行的标签是附注标签，<code>^</code> 所在的那一行是附注标签指向的那个提交。</p>
<h4 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h4><p>关键在于找到 SHA-1</p>
<ul>
<li><code>git reflog</code> - 引用日志<ul>
<li>引用日志数据存放在 <code>.git/logs/</code> 目录中</li>
</ul>
</li>
<li>没有引用日志？需检查数据库完整性。<ul>
<li>使用 <code>git fsck</code> 实用工具检查数据库的完整性。使用一个 <code>--full</code> 选项运行它，它会向你显示出所有没有被其他对象指向的对象</li>
</ul>
</li>
</ul>
<h4 id="移除对象"><a href="#移除对象" class="headerlink" title="移除对象"></a>移除对象</h4><p><code>git clone</code> 会下载整个项目的历史，包括每一个文件的每一个版本。如果某个人在之前向项目添加了一个大小特别大的文件，即使你将这个文件从项目中移除了，每次克隆还是都要强制的下载这个大文件。</p>
<p>如何操作来解决？去查看原文。</p>
<p>执行 <code>count-objects</code> 命令来快速的查看占用空间大小</p>
<h2 id="10-8-Git-内部原理-环境变量"><a href="#10-8-Git-内部原理-环境变量" class="headerlink" title="10.8 Git 内部原理 - 环境变量"></a>10.8 Git 内部原理 - 环境变量</h2><p>:speech_balloon: 这里从文中摘录一些有意思的环境变量：</p>
<ul>
<li><p><strong>GIT_GLOB_PATHSPECS 和 GIT_NOGLOB_PATHSPECS</strong> 控制通配符在路径规则中的默认行为。</p>
<p>如果 <code>GIT_GLOB_PATHSPECS</code> 设置为 1, 通配符表现为通配符（这是默认设置）; 如果 <code>GIT_NOGLOB_PATHSPECS</code> 设置为 1,通配符仅匹配字面。你可以在各个路径规格中用 <code>:(glob)</code> 或 <code>:(literal)</code> 开头来覆盖这个配置，如 <code>:(glob)*.c</code> 。</p>
</li>
<li><p>如果 <code>user.email</code> 没有配置， 就会用到 <strong>EMAIL</strong> 指定的邮件地址。如果 <em>这个</em> 也没有设置， Git 继续回退使用系统用户和主机名。</p>
</li>
<li><p><strong>GIT_HTTP_USER_AGENT</strong> 设置 Git 在通过 HTTP 通讯时用到的 user-agent。</p>
</li>
<li><p><strong>GIT_MERGE_VERBOSITY</strong> 控制递归合并策略的输出。 允许的值有下面这些：</p>
</li>
</ul>
<blockquote>
<p>0 什么都不输出，除了可能会有一个错误信息。<br>1 只显示冲突。<br>2 还显示文件改变。（默认）<br>3 显示因为没有改变被跳过的文件。<br>4 显示处理的所有路径。<br>5 显示详细的调试信息。</p>
</blockquote>
<ul>
<li><p>指定 <strong>GIT_SSH</strong>， Git 连接 SSH 主机时会用指定的程序代替 <code>ssh</code> 。用 <code>$GIT_SSH [username@]host [-p &lt;port&gt;] &lt;command&gt;</code> 的命令方式调用。可能用 <code>~/.ssh/config</code> 会更简单。</p>
</li>
<li><p><strong>GIT_ICASE_PATHSPECS</strong> 让所有的路径规格忽略大小写。</p>
</li>
</ul>
<h2 id="10-9-Git-内部原理-总结"><a href="#10-9-Git-内部原理-总结" class="headerlink" title="10.9 Git 内部原理 - 总结"></a>10.9 Git 内部原理 - 总结</h2><p>作为一套内容寻址文件系统，Git <strong><em>不仅仅是</em>一个版本控制系统</strong>，它同时是一个非常强大且易用的工具。 我们希望你可以借助新学到的 Git 内部原理相关知识来实现出自己的应用。</p>
<h1 id="Supplements"><a href="#Supplements" class="headerlink" title="Supplements"></a>Supplements</h1><h2 id="1-改写提交"><a href="#1-改写提交" class="headerlink" title="1. 改写提交"></a>1. 改写提交</h2><p>**<code>git cherry-pick</code> **</p>
<p>可以用于将在其他分支上的 commit 修改，移植到当前的分支。</p>
<p>它并不是把原来的 commit 剪过来这边贴上，而是复制 commit 的内容过来。需要重新计算，产生一个新的 Commit （SHA 值不同）。</p>
<p>注意一定要根据时间线，依照 commit 的先后顺序来处理，否则会有意想不到的问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git cherry-pick 6a498ec</span><br><span class="line">$ git cherry-pick -x &lt;commit_id&gt;       # 参数 -x 新的提交中保留原作者信息</span><br><span class="line">$ git cherry-pick fd23e1 6a498e f4f444 # pick 多个提交</span><br><span class="line">$ git cherry_pick &lt;start&gt;…&lt;end-commit&gt; # 批量 cherry-pick (Git &gt;&#x3D; 1.7.2)</span><br><span class="line">$ git cherry-pick fd23e1c^...6a498ec   # 灵活使用三点语法</span><br><span class="line">$ git cherry-pick 6a498ec --no-commit  # cherry-pick 后不提交，先放暂存区</span><br></pre></td></tr></table></figure>


<p><strong><code>git merge --squash</code></strong></p>
<p>Produce the working tree and index state as if a real merge happened (<em>except for the merge information</em>), but <em>do not actually make a commit</em>, move the <code>HEAD</code>, or record <code>$GIT_DIR/MERGE_HEAD</code><em>(to cause the next <code>git commit</code> command to create a merge commit)</em>.  This <em>allows you to create a single commit</em> on top of the current branch whose effect is the same as merging another branch.</p>
<p><code>merge  --squash</code> 后需要执行一条额外的commit命令。Git不会做提交，原来的commit历史也没有拿过来。</p>
<p><code>--no-squash</code> can be used to override <code>--squash</code></p>
<p><strong><code>git revert</code></strong></p>
<p>版本回退。再做一个新的 Commit，来取消你不要的 Commit，所以 Commit 数量才会增加。此次操作之后的commit会保留。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git revert HEAD [--no-edit]</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>--no-edit</code>      With this option, <em>git revert</em> will not start the commit message editor.</p>
<p><code>-no-commit</code>    This flag applies the changes necessary to revert the named commits to your working tree and the index, but <em>does not make the commits</em>.</p>
</blockquote>
<p>这三个指令有什么差別？</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>改变历史</th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Reset</td>
<td>是</td>
<td>把目前的状态设定成某个指定的 Commit 的状态，通常适用于尚未推出去的Commit。</td>
</tr>
<tr>
<td>Rebase</td>
<td>是</td>
<td>不管是新增、修改、删除 Commit 都相当方便，用来整理、编辑还没有推出去的Commit 相当方便，但通常也只适用于尚未推出去的 Commit。</td>
</tr>
<tr>
<td>Revert</td>
<td>否</td>
<td>新增一个 Commit 来反转另一个 Commit 的内容，原本的 Commit 依旧还是会保留在历史记录中。虽然会因此而增加 Commit 数，但通常比较适用于已经推出去的Commit，或是不允许使用 Reset 或 Rebase 的场合。</td>
</tr>
</tbody></table>
<h1 id="Appendix-1-Git-分支管理最佳实践"><a href="#Appendix-1-Git-分支管理最佳实践" class="headerlink" title="Appendix 1 / Git 分支管理最佳实践"></a><small>Appendix 1</small> / Git 分支管理最佳实践</h1><h3 id="单主干"><a href="#单主干" class="headerlink" title="单主干"></a>单主干</h3><ul>
<li>所有成员都在 master 分支上进行开发</li>
<li>使用 tag 或发布分支进行发布</li>
<li>在 master 分支中修复 bug，再 cheery-pick解释 到发布分支</li>
<li>适用于小项目</li>
<li>因为在同一分支上进行开发，协作人员之间必须有良好的交流</li>
<li>省去另开分支的时间，不用频繁切换分支</li>
</ul>
<h3 id="Github-Flow"><a href="#Github-Flow" class="headerlink" title="Github Flow"></a>Github Flow</h3><ul>
<li>只包含两类分支：master 和修改分支，master 作为部署分支</li>
<li>无论是 feature，bug 还是 hotfix 都从 master  另开分支</li>
<li>从分支到 master 的合并需要提交 pull  request</li>
<li>在 pull request 上需要进行代码审查和测试，通过后再合并</li>
<li>Release 在 master 上通过 tag 进行标记</li>
<li>对自动化测试、持续集成等相关基础设施要求较高，新分支的测试和部署人工操作较为繁杂</li>
</ul>
<h3 id="Git-Flow"><a href="#Git-Flow" class="headerlink" title="Git Flow"></a>Git Flow</h3><ul>
<li>同样以 master 作为部署分支，其上所有 commit 都应围绕版本而生</li>
<li>共有五类分支 master，develop，feature，release 和 hotfix</li>
<li>Release 分支测试的问题直接在 release 分支上修改，测试完毕后再分别合并到 master 和 develop，相当于 develop 的需求冻结，可以让新功能开发和版本测试同步进行</li>
<li>合并时多数情况不使用 fast-forward 模式</li>
<li>Hotfix 分支用于修复线上问题，向 master 和 develop 合并</li>
<li>Feature，release，hotfix 分支合并完成后应被删除</li>
<li>操作较为繁琐，有对应的命令行工具</li>
<li>较为适合于长期大型项目</li>
</ul>
<table>
<thead>
<tr>
<th>分支类型</th>
<th>命名规范</th>
<th>创建自</th>
<th>合并至</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>master</td>
<td>master</td>
<td>-</td>
<td>-</td>
<td>部署版本分支</td>
</tr>
<tr>
<td>develop</td>
<td>develop</td>
<td>-</td>
<td>-</td>
<td>代码集成分支</td>
</tr>
<tr>
<td>feature</td>
<td>feature/*</td>
<td>develop</td>
<td>develop</td>
<td>新功能</td>
</tr>
<tr>
<td>release</td>
<td>release/*</td>
<td>develop</td>
<td>develop 和 master</td>
<td>一次新版本的发布</td>
</tr>
<tr>
<td>hotfix</td>
<td>hotfix/*</td>
<td>master</td>
<td>develop 和 master</td>
<td>生产环境中发现的紧急 bug 的修复</td>
</tr>
</tbody></table>
<h3 id="团队项目版本管理方案"><a href="#团队项目版本管理方案" class="headerlink" title="团队项目版本管理方案"></a>团队项目版本管理方案</h3><blockquote>
<p><strong>核心问题</strong></p>
<ul>
<li>如何进行分支管理，怎样合并</li>
<li>是否要进行代码审阅、评论</li>
<li>是否以及如何进行测试和部署</li>
<li>围绕人为核心还是功能为核心</li>
</ul>
</blockquote>
<h3 id="单人小项目"><a href="#单人小项目" class="headerlink" title="单人小项目"></a>单人小项目</h3><h4 id="关注点"><a href="#关注点" class="headerlink" title="关注点"></a>关注点</h4><ul>
<li>单人完成项目，无需他人审查</li>
<li>小功能快速迭代，无需额外的 feature 分支</li>
<li>主要目标为保存代码进度及回退</li>
<li>需要注意对接交递项目时的问题</li>
</ul>
<h4 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h4><ol>
<li>单主干</li>
<li>Master + develop 混合  <ul>
<li>Develop 分支进行开发、修复</li>
<li>Master 分支进行版本发布、部署</li>
</ul>
</li>
</ol>
<h3 id="多人协作项目"><a href="#多人协作项目" class="headerlink" title="多人协作项目"></a>多人协作项目</h3><h4 id="关注点-1"><a href="#关注点-1" class="headerlink" title="关注点"></a>关注点</h4><ul>
<li>需要一定的代码审查</li>
<li>需要保证沟通的效率</li>
<li>分支与对应功能绑定</li>
<li>潜在的代码审核</li>
</ul>
<h4 id="方案-1"><a href="#方案-1" class="headerlink" title="方案"></a>方案</h4><ol>
<li>Github Flow</li>
<li>Git Flow 简化  <ul>
<li>单一 develop 分支</li>
<li>可选的 hotfix 分支</li>
</ul>
</li>
</ol>
<h3 id="组内共享项目"><a href="#组内共享项目" class="headerlink" title="组内共享项目"></a>组内共享项目</h3><h4 id="关注点-2"><a href="#关注点-2" class="headerlink" title="关注点"></a>关注点</h4><ul>
<li>以分享知识和共同进步为核心</li>
<li>代码以人为本</li>
<li>需要 merge request，共同评论，学习他人优秀代码以及提出改进意见</li>
</ul>
<h4 id="方案-2"><a href="#方案-2" class="headerlink" title="方案"></a>方案</h4><ul>
<li>Master + develop 主开发分支</li>
<li>从 develop 分支分出 [username]/dev 个人开发分支</li>
<li>个人开发分支上可使用任意的模式</li>
<li>从 [username]/dev 禁止合并到 develop </li>
<li>需要合并及需要从 develop 分支拉去时从 /dev 分支分出 [username]/merge/[mm-dd] 分支并提交 merge request，冻结个人代码版本</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/12/12/Pro-Git-Tips/" data-id="ckm7t0sot0007gkugfsl57vbj" data-title="Pro Git Tips" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Git/" rel="tag">Git</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Pro-Git-Reading-Note-Part-II" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/11/18/Pro-Git-Reading-Note-Part-II/" class="article-date">
  <time class="dt-published" datetime="2018-11-18T05:15:57.000Z" itemprop="datePublished">2018-11-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/11/18/Pro-Git-Reading-Note-Part-II/">Pro Git Reading Note Part II</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Git-Guide"><a href="#Git-Guide" class="headerlink" title="Git Guide"></a>Git Guide</h1><h2 id="7-2-Git-工具-交互式暂存"><a href="#7-2-Git-工具-交互式暂存" class="headerlink" title="7.2 Git 工具 - 交互式暂存"></a>7.2 Git 工具 - 交互式暂存</h2><p>text-rendering<br>/* Keyword values */<br>text-rendering: auto;<br>text-rendering: optimizeSpeed;<br>text-rendering: optimizeLegibility;<br>text-rendering: geometricPrecision;</p>
<h2 id="7-14-Git-工具-凭证存储"><a href="#7-14-Git-工具-凭证存储" class="headerlink" title="7.14 Git 工具 - 凭证存储"></a>7.14 Git 工具 - 凭证存储</h2><h4 id="Git-凭证存储"><a href="#Git-凭证存储" class="headerlink" title="Git 凭证存储"></a>Git 凭证存储</h4><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;#36; git config --global credential.helper cache</span><br></pre></td></tr></table></figure>
<ul>
<li>default</li>
<li>cache</li>
<li>store</li>
<li>osxkeychain</li>
<li>winstore</li>
</ul>
<p>Git 甚至允许<strong>你配置多个辅助工具</strong>。 当查找特定服务器的凭证时，Git 会按顺序查询，并且<strong>在找到第一个回答时停止查询</strong>。 当保存凭证时，Git 会将用户名和密码发送给 <strong>所有</strong> 配置列表中的辅助工具，它们会按自己的方式处理用户名和密码。 如果你在闪存上有一个凭证文件，但又希望在该闪存被拔出的情况下使用内存缓存来保存用户名密码，<code>.gitconfig</code> 配置文件如下：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[credential]</span></span><br><span class="line">    <span class="attr">helper</span> = store --file /mnt/thumbdrive/.git-credentials</span><br><span class="line">    <span class="attr">helper</span> = cache --timeout <span class="number">30000</span></span><br></pre></td></tr></table></figure>
<ul>
<li>也可自己写一个认证程序 *</li>
<li>正如你看到的，扩展这个系统是相当简单的！</li>
</ul>
<p>当你碰到问题时，你应该可以很容易找出是哪个分支在什么时候由谁引入了它们。 如果你想在项目中使用子项目，你也已经知道如何来满足这些需求。 到此，<strong>你应该能毫无压力地在命令行中使用 Git 来完成日常中的大部分事情</strong>。</p>
<h2 id="8-1-自定义-Git-配置-Git"><a href="#8-1-自定义-Git-配置-Git" class="headerlink" title="8.1 自定义 Git - 配置 Git"></a>8.1 自定义 Git - 配置 Git</h2><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;#36; git config --global core.editor emacs</span><br></pre></td></tr></table></figure>
<ul>
<li><p>:heart:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;#36; git config --global commit.template ~&#x2F;.gitmessage.txt</span><br></pre></td></tr></table></figure></li>
<li><p>全局排除 :heart:<br> <code>git config --global core.excludesfile ~/.gitignore_global</code></p>
<blockquote>
<p><code>core.excludesFile</code><br> Specifies the pathname to the file that contains patterns to describe paths that are not meant to be tracked, in addition to .gitignore (per-directory) and .git/info/exclude. Defaults to &#36;XDG_CONFIG_HOME/git/ignore. If &#36;XDG_CONFIG_HOME is either not set or empty, &#36;HOME/.config/git/ignore is used instead. See gitignore[5].</p>
</blockquote>
</li>
<li><p>如果你把 <code>help.autocorrect</code> 设置成 1，那么只要有一个命令被模糊匹配到了，Git 会自动运行该命令。</p>
</li>
</ul>
<h5 id="外部的合并与比较工具"><a href="#外部的合并与比较工具" class="headerlink" title="外部的合并与比较工具"></a>外部的合并与比较工具</h5><ul>
<li><p><code>git mergetool --tool=&lt;tool&gt;&lt;/tool&gt;</code></p>
<blockquote>
<p>-t <tool></tool></p>
<p>–tool=<tool></tool></p>
<p>Use the merge resolution program specified by <tool></tool>. <u>Valid values include emerge, gvimdiff, kdiff3, meld, vimdiff, and tortoisemerge. Run <code>git mergetool --tool-help</code> for the list of valid <tool></tool> settings.</u></p>
<p><u>If a merge resolution program is not specified, <em>git mergetool</em> will use the configuration variable<code>merge.tool</code></u>. If the configuration variable <code>merge.tool</code> is not set, <em>git mergetool</em> will pick a suitable default.</p>
</blockquote>
</li>
<li><p><code>diff.external</code></p>
<blockquote>
<p>If this config variable is set, diff generation is not performed using the internal diff machinery, but using the given command. Can be overridden with the ‘GIT_EXTERNAL_DIFF’ environment variable.</p>
</blockquote>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/11/18/Pro-Git-Reading-Note-Part-II/" data-id="ckm7t0sos0006gkug1tuyb2mh" data-title="Pro Git Reading Note Part II" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Git/" rel="tag">Git</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Pro-Git-Reading-Note-Part-I" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/10/18/Pro-Git-Reading-Note-Part-I/" class="article-date">
  <time class="dt-published" datetime="2018-10-18T05:13:12.000Z" itemprop="datePublished">2018-10-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/10/18/Pro-Git-Reading-Note-Part-I/">Pro Git Reading Note Part I</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <!-- <div class="ql-editor" data-gramm="false" contenteditable="true">  -->

<p><code>git remote show</code></p>
<p><span style="background-color: rgb(252, 252, 250); color: rgb(78, 68, 60);">为这种情况下的合并操作没有需要解决的分歧——这就叫做 “快进（fast-forward）”</span></p>
<p><span style="background-color: rgb(252, 252, 250); color: rgb(78, 68, 60);">Git 自动将 </span><code>serverfix</code><span style="background-color: rgb(252, 252, 250); color: rgb(78, 68, 60);"> 分支名字展开为</span><code>refs/heads/serverfix:refs/heads/serverfix</code><span style="background-color: rgb(252, 252, 250); color: rgb(78, 68, 60);">，那意味着，“推送本地的 serverfix 分支来更新远程仓库上的 serverfix 分支。” 我们将会详细学习 </span><a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/ch00/ch10-git-internals">Git 内部原理</a><span style="background-color: rgb(252, 252, 250); color: rgb(78, 68, 60);"> 的 </span><code>refs/heads/</code><span style="background-color: rgb(252, 252, 250); color: rgb(78, 68, 60);"> 部分，但是现在可以先把它放在儿。 你也可以运行 </span><code>gi</code></p>
<h1 id="3-5-Git-分支-远程分支"><a href="#3-5-Git-分支-远程分支" class="headerlink" title="3.5 Git 分支 - 远程分支"></a>3.5 Git 分支 - 远程分支</h1><h3 id="跟踪分支"><a href="#跟踪分支" class="headerlink" title="跟踪分支"></a><strong>跟踪分支</strong></h3><p>从一个远程跟踪分支检出一个本地分支会自动创建一个叫做 “跟踪分支”（有时候也叫做 “上游分支”）。 跟踪分支是与远程分支有直接关系的本地分支。 如果在一个跟踪分支上输入 <code>git pull</code>，Git 能自动地识别去哪个服务器上抓取、合并到哪个分支。</p>
<p>当克隆一个仓库时，它通常会自动地创建一个跟踪 origin/master 的 master 分支。 然而，如果你愿意的话可以设置其他的跟踪分支 - 其他远程仓库上的跟踪分支，或者不跟踪 master 分支。 最简单的就是之前看到的例子，运行 git checkout -b [branch] [remotename]/[branch]。 这是一个十分常用的操作所以 Git 提供了 –track 快捷方式：</p>
<pre spellcheck="false">$ git checkout --track origin/serverfix       
</pre>

<p><a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF">https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF</a></p>
<p>clone下来的repo在本地默认只有master分支。</p>
<p>上游快捷方式</p>
<p><span style="background-color: rgb(255, 242, 133);">当设置好跟踪分支后，可以通过 </span><code>@&#123;upstream&#125;</code><span style="background-color: rgb(255, 242, 133);"> 或 </span><code>@&#123;u&#125;</code><span style="background-color: rgb(255, 242, 133);"> 快捷方式来引用它</span>。 所以在 <code>master</code> 分支时并且它正在跟踪 <code>origin/master</code> 时，如果愿意的话可以使用 <code>git merge @&#123;u&#125;</code> 来取代 <code>git merge origin/master</code>。</p>
<h3 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a><strong>删除远程分支</strong></h3><pre spellcheck="false">git push origin --delete serverfix          
</pre>

<h1 id="3-6-Git-分支-变基"><a href="#3-6-Git-分支-变基" class="headerlink" title="3.6 Git 分支 - 变基"></a>3.6 Git 分支 - 变基</h1><pre spellcheck="false"> git rebase --onto master server client          
</pre>

<ul>
<li>  <span style="background-color: rgb(255, 242, 133);">如果不加 onto 会发生什么？</span></li>
<li>  好好研究一下 rebase 的 options</li>
</ul>
<pre spellcheck="false">git rebase [-i | --interactive] [&lt;options&gt;] [--exec &lt;cmd&gt;] [--onto &lt;newbase&gt;]  [&lt;upstream&gt; [&lt;branch&gt;]] git rebase [-i | --interactive] [&lt;options&gt;] [--exec &lt;cmd&gt;] [--onto &lt;newbase&gt;]  --root [&lt;branch&gt;] git rebase --continue | --skip | --abort | --quit | --edit-todo | --show-current-patch          
</pre>

<h3 id="用变基解决变基"><a href="#用变基解决变基" class="headerlink" title="用变基解决变基"></a><strong>用变基解决变基</strong></h3><p>如果你 <strong>真的</strong> 遭遇了类似的处境，Git 还有一些高级魔法可以帮到你。 如果团队中的某人强制推送并覆盖了一些你所基于的提交，你需要做的就是检查你做了哪些修改，以及他们覆盖了哪些修改。<span style="background-color: rgb(252, 252, 250); color: rgb(78, 68, 60);">如果你或你的同事在某些情形下决意要这么做，请一定要通知每个人执行 </span><code>git pull --rebase</code><span style="background-color: rgb(252, 252, 250); color: rgb(78, 68, 60);"> </span><em>总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史，从不对已推送至别处的提交执行变基操作，这样，你才能享受到两种方式带来的便利</em><span style="background-color: rgb(252, 252, 250); color: rgb(78, 68, 60);">。</span></p>
<h1 id="4-1-服务器上的-Git-协议"><a href="#4-1-服务器上的-Git-协议" class="headerlink" title="4.1 服务器上的 Git - 协议"></a>4.1 服务器上的 Git - 协议</h1><p>HTTPS 如何指定证书？</p>
<p><span style="background-color: rgb(252, 252, 250); color: rgb(78, 68, 60);">裸仓库目录名以 .git 结尾</span></p>
<h1 id="5-2-分布式-Git-向一个项目贡献"><a href="#5-2-分布式-Git-向一个项目贡献" class="headerlink" title="5.2 分布式 Git - 向一个项目贡献"></a>5.2 分布式 Git - 向一个项目贡献</h1><p><span style="background-color: rgb(252, 252, 250); color: rgb(78, 68, 60);">运行 </span><code>git diff --check</code><span style="background-color: rgb(252, 252, 250); color: rgb(78, 68, 60);">，它将会找到可能的空白错误并将它们为你列出来</span></p>
<h1 id="7-1-Git-工具-选择修订版本"><a href="#7-1-Git-工具-选择修订版本" class="headerlink" title="7.1 Git 工具 - 选择修订版本"></a>7.1 Git 工具 - 选择修订版本</h1><p><span style="background-color: rgb(252, 252, 250); color: rgb(78, 68, 60);">值得注意的是，引用日志只存在于本地仓库，一个记录你在你自己的仓库里做过什么的日志。 其他人拷贝的仓库里的引用日志不会和你的相同；而你新克隆一个仓库的时候，引用日志是空的，因为你在仓库里还没有操作。</span></p>
<ul>
<li>  SHA-1</li>
<li>  <span style="color: rgb(78, 68, 60); background-color: rgb(252, 252, 250);">当然你提供的 SHA-1 字符数量不得少于 4 个，并且没有歧义</span></li>
<li>  分支引用</li>
<li>  引用日志(reflog)：<code>HEAD@&#123;5&#125;</code>  <code>master@&#123;yesterday&#125;</code></li>
<li>  <code>git reflog</code> 来查看日志</li>
<li>  祖先引用： <code>HEAD^</code>     <code>HEAD^2</code>   第二父提交</li>
<li>  <code>HEAD~2</code>  第一父提交的第一父提交 = <code>HEAD^^</code></li>
<li>  <code>^2</code> 与 <code>~2</code> 的区别 </li>
<li>  提交区间</li>
<li>  <code>master..experiment</code>   experiment 分支中未在 master 分支（哪些提交尚未被合并入 master 分支</li>
<li>  <code>master...experiment</code> 如果你想看 <code>master</code> 或者 <code>experiment</code> 中包含的但不是两者共有的提交</li>
</ul>
<p>因此下列3个命令是等价的：</p>
<pre spellcheck="false">$ git log refA..refB $ git log ^refA refB $ git log refB --not refA      
</pre>

<p>你想查看所有被 <code>refA</code> 或 <code>refB</code> 包含的但是不被 <code>refC</code> 包含的提交</p>
<pre spellcheck="false">$ git log refA refB ^refC $ git log refA refB --not refC      
</pre>

<p>另一个常用的场景是查看你即将推送到远端的内容：</p>
<pre spellcheck="false">$ git log origin/master..HEAD          
</pre>

<p>这个命令会输出在你当前分支中而不在远程 <code>origin</code> 中的提交。</p>
<h1 id="7-2-Git-工具-交互式暂存"><a href="#7-2-Git-工具-交互式暂存" class="headerlink" title="7.2 Git 工具 - 交互式暂存"></a>7.2 Git 工具 - 交互式暂存</h1><p><span style="color: rgb(78, 68, 60); background-color: rgb(252, 252, 250);">运行 </span><code>git add</code><span style="color: rgb(78, 68, 60); background-color: rgb(252, 252, 250);"> 时使用 </span><code>-i</code><span style="color: rgb(78, 68, 60); background-color: rgb(252, 252, 250);"> 或者 </span><code>--interactive</code><span style="color: rgb(78, 68, 60); background-color: rgb(252, 252, 250);"> 选项，Git 将会进入一个交互式终端模式</span></p>
<p>可以在命令行中使用 <code>git add -p</code> 或 <code>git add --patch</code>来启动同样的脚本。</p>
<p>更进一步地，可以使用 <code>reset --patch</code> 命令的补丁模式来部分重置文件，通过 <code>checkout --patch</code> 命令来部分检出文件与 <code>stash save --patch</code> 命令来部分暂存文件。</p>
<p><span style="color: rgb(78, 68, 60); background-color: rgb(252, 252, 250);">默认情况下，</span><code>git clean</code><span style="color: rgb(78, 68, 60); background-color: rgb(252, 252, 250);"> 命令只会移除没有忽略的未跟踪文件。 任何与 </span><code>.gitiignore</code><span style="color: rgb(78, 68, 60); background-color: rgb(252, 252, 250);"> 或其他忽略文件中的模式匹配的文件都不会被移除。 </span></p>
<p><span style="color: rgb(78, 68, 60); background-color: rgb(252, 252, 250);">现在运行 </span><code>git status</code><span style="color: rgb(78, 68, 60); background-color: rgb(252, 252, 250);"> 会没有输出，因为三棵树又变得相同了。</span></p>
<p><code>reset</code><span style="color: rgb(78, 68, 60); background-color: rgb(252, 252, 250);"> 做的第一件事是移动 HEAD 的指向。 这与改变 HEAD 自身不同（</span><code>checkout</code><span style="color: rgb(78, 68, 60); background-color: rgb(252, 252, 250);"> 所做的）；</span><code>reset</code><span style="color: rgb(78, 68, 60); background-color: rgb(252, 252, 250);"> 移动 HEAD 指向的分支。</span></p>
<h1 id="7-7-Git-工具-重置揭密-TODO"><a href="#7-7-Git-工具-重置揭密-TODO" class="headerlink" title="7.7 Git 工具 - 重置揭密 [TODO]"></a>7.7 Git 工具 - 重置揭密 [TODO]</h1><p>值得好好看一下</p>
<h1 id="7-3-Git-工具-储藏与清理"><a href="#7-3-Git-工具-储藏与清理" class="headerlink" title="7.3 Git 工具 - 储藏与清理"></a>7.3 Git 工具 - 储藏与清理</h1><ul>
<li>  文中出现的 <code>git stash</code> 的各种参数和用法</li>
</ul>
<p><span style="background-color: rgb(252, 252, 250); color: rgb(78, 68, 60);">因为它被设计为从工作目录中移除未被追踪的文件。 如果你改变主意了，你也不一定能找回来那些文件的内容。 一个更安全的选项是运行 </span><code>git stash --all</code><span style="background-color: rgb(252, 252, 250); color: rgb(78, 68, 60);"> 来移除每一样东西并存放在栈中。</span></p>
<p><span style="background-color: rgb(252, 252, 250); color: rgb(78, 68, 60);">默认情况下，</span><code>git clean</code><span style="background-color: rgb(252, 252, 250); color: rgb(78, 68, 60);"> 命令</span><strong>只会移除没有忽略的未跟踪文件</strong><span style="background-color: rgb(252, 252, 250); color: rgb(78, 68, 60);">。</span>** **<strong>任何与 <strong><code>**.gitiignore**</code></strong> 或其他忽略文件中的模式匹配的文件都不会被移除</strong><span style="background-color: rgb(252, 252, 250); color: rgb(78, 68, 60);">。 如果你也想要移除那些文件，可以给 clean 命令增加一个 </span><code>-x</code><span style="background-color: rgb(252, 252, 250); color: rgb(78, 68, 60);"> 选项。</span></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/10/18/Pro-Git-Reading-Note-Part-I/" data-id="ckm7t0soq0004gkug12ye8nx8" data-title="Pro Git Reading Note Part I" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Git/" rel="tag">Git</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/LaTeX/">LaTeX</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Context/" rel="tag">Context</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Flex/" rel="tag">Flex</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/" rel="tag">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTPS/" rel="tag">HTTPS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Javascript/" rel="tag">Javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LaTeX/" rel="tag">LaTeX</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Promise/" rel="tag">Promise</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/" rel="tag">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SSH/" rel="tag">SSH</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/V2Ray/" rel="tag">V2Ray</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vim/" rel="tag">Vim</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Webpack/" rel="tag">Webpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/blend-mode/" rel="tag">blend mode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mask/" rel="tag">mask</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/" rel="tag">发布订阅</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/" rel="tag">密码学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/" rel="tag">开发工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F/" rel="tag">混合模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/" rel="tag">科学上网</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%95%82%E7%A9%BA/" rel="tag">镂空</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/CSS/" style="font-size: 16.67px;">CSS</a> <a href="/tags/Context/" style="font-size: 10px;">Context</a> <a href="/tags/Flex/" style="font-size: 10px;">Flex</a> <a href="/tags/Git/" style="font-size: 20px;">Git</a> <a href="/tags/HTTPS/" style="font-size: 10px;">HTTPS</a> <a href="/tags/Javascript/" style="font-size: 10px;">Javascript</a> <a href="/tags/LaTeX/" style="font-size: 13.33px;">LaTeX</a> <a href="/tags/Promise/" style="font-size: 10px;">Promise</a> <a href="/tags/React/" style="font-size: 10px;">React</a> <a href="/tags/SSH/" style="font-size: 10px;">SSH</a> <a href="/tags/V2Ray/" style="font-size: 10px;">V2Ray</a> <a href="/tags/Vim/" style="font-size: 13.33px;">Vim</a> <a href="/tags/Webpack/" style="font-size: 10px;">Webpack</a> <a href="/tags/blend-mode/" style="font-size: 10px;">blend mode</a> <a href="/tags/mask/" style="font-size: 10px;">mask</a> <a href="/tags/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/" style="font-size: 10px;">发布订阅</a> <a href="/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/" style="font-size: 10px;">密码学</a> <a href="/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/" style="font-size: 10px;">开发工具</a> <a href="/tags/%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">混合模式</a> <a href="/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/" style="font-size: 10px;">科学上网</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">设计模式</a> <a href="/tags/%E9%95%82%E7%A9%BA/" style="font-size: 10px;">镂空</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">二月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/03/13/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2021/02/24/%E6%9D%82%E8%B0%88%EF%BC%9A%E6%80%8E%E6%A0%B7%E6%95%B4%E7%90%86%E5%90%84%E5%BC%8F%E5%90%84%E6%A0%B7%E7%9A%84%E4%B8%AA%E4%BA%BA%E6%96%87%E4%BB%B6%EF%BC%9F/">杂谈：怎样整理各式各样的个人文件？</a>
          </li>
        
          <li>
            <a href="/2020/06/28/%E6%80%8E%E6%A0%B7%E8%88%92%E9%80%82%E5%9C%B0%E4%BD%BF%E7%94%A8Vim%E7%A0%81%E5%AD%97%E5%86%99%E6%96%87%E7%AB%A0/">怎样舒适地使用 Vim 码字写文章</a>
          </li>
        
          <li>
            <a href="/2019/11/25/LaTeX%E5%85%A5%E9%97%A8%E5%B0%8F%E8%AE%B0%EF%BC%9AVim+Vimtex+LaTeX%E5%88%9D%E4%BD%93%E9%AA%8C/">LaTeX 入门小记：Vim + Vimtex + LaTeX 初体验</a>
          </li>
        
          <li>
            <a href="/2019/02/22/%E7%94%A8%E7%BA%AFCSS%E5%AE%9E%E7%8E%B0%E9%95%82%E7%A9%BA%E6%95%88%E6%9E%9C/">用纯 CSS 实现镂空效果</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 Cattle<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>